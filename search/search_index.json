{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GRiNS","text":"<p>A python package for simulating and analysing the dynamics of Gene Regulatory Networks (GRNs). This uses Diffrax</p> <p>Documentation: MoltenEcdysone09.github.io/GRiNS</p>"},{"location":"#installation","title":"Installation","text":"<ul> <li>For cpu only:</li> </ul> <pre><code>pip install grins\n</code></pre> <ul> <li>If you want to use gpu:</li> </ul> <pre><code>pip install grins[cuda12]\n</code></pre>"},{"location":"#citation","title":"Citation","text":""},{"location":"api/IsingBoolean/","title":"Ising Boolean Formalism","text":"<p>Functions related to Ising simulation.</p>"},{"location":"api/IsingBoolean/#grn-parsing-and-intial-condition-generation-functions","title":"GRN Parsing and Intial Condition Generation Functions","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.parse_topo_to_matrix","title":"<code>grins.ising_bool.parse_topo_to_matrix(topofile_path)</code>","text":"<p>Parses a topology file into an adjacency matrix.</p> <p>This function reads a topology file, and converts it into an adjacency matrix. The adjacency matrix is then converted to a JAX array.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The path to the topology file. The file should be in a format              readable by pandas <code>read_csv</code> with whitespace as the delimiter.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing: - topo_adj (jax.numpy.ndarray): The adjacency matrix as a JAX array. - node_names (list): A list of node names in the order they appear in the adjacency matrix.</p>"},{"location":"api/IsingBoolean/#grins.ising_bool.parse_topo_to_matrix(topofile_path)","title":"<code>topofile_path</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.generate_intial_conditions","title":"<code>grins.ising_bool.generate_intial_conditions(num_nodes, num_samples)</code>","text":"<p>Generate initial conditions for a given number of nodes and samples.</p> <p>This function generates initial conditions using Sobol sequences and scales the generated samples to [0, 1].</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The number of nodes for which to generate initial conditions.</p> required <code>int</code> <p>The number of samples to generate.</p> required <p>Returns:</p> Type Description <p>jax.numpy.ndarray: The generated initial conditions as a JAX array of integers</p>"},{"location":"api/IsingBoolean/#grins.ising_bool.generate_intial_conditions(num_nodes)","title":"<code>num_nodes</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.generate_intial_conditions(num_samples)","title":"<code>num_samples</code>","text":""},{"location":"api/IsingBoolean/#ising-boolean-simulation-functions","title":"Ising Boolean Simulation Functions","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.sync_eval_next_state","title":"<code>grins.ising_bool.sync_eval_next_state(prev_state, topo_adj, replacement_values)</code>","text":"<p>Evaluate the next state of a system synchronously based on the previous state, topology adjacency matrix, and replacement values.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The previous state of the system.</p> required <code>ndarray</code> <p>The topology adjacency matrix representing the connections between nodes in the system.</p> required <code>ndarray</code> <p>A vector of two values used for replacement based on the computed state conditions. The values are: [value_if_negative, value_if_positive].</p> required <p>Returns:</p> Type Description <p>jnp.ndarray: The new state of the system as an array of int16.</p>"},{"location":"api/IsingBoolean/#grins.ising_bool.sync_eval_next_state(prev_state)","title":"<code>prev_state</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.sync_eval_next_state(topo_adj)","title":"<code>topo_adj</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.sync_eval_next_state(replacement_values)","title":"<code>replacement_values</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_sync_trajectory","title":"<code>grins.ising_bool.simulate_sync_trajectory(initial_condition, topo_adj, replacement_values, max_steps)</code>","text":"<p>Simulates a synchronous trajectory of a system based on the given initial condition, topology adjacency matrix, and replacement values.</p> <p>Parameters:</p> Name Type Description Default <code>array - like</code> <p>The initial state of the system.</p> required <code>array - like</code> <p>The topology adjacency matrix representing the connections between nodes.</p> required <code>array - like</code> <p>The values used to replace the states during the simulation. It is a vector of two values in the form [value_if_negative, value_if_positive].</p> required <code>jnp.arange array</code> <p>The range of steps to simulate. The simulation will run for each step in the range.</p> required <p>Returns:</p> Type Description <p>jnp.ndarray: A JAX array containing the states of the system at each step, with the initial condition included at the beginning. The array also includes a column for the step indices. All -1 values in the states are replaced with 0 if the replacement values are [-1, 1].</p>"},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_sync_trajectory(initial_condition)","title":"<code>initial_condition</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_sync_trajectory(topo_adj)","title":"<code>topo_adj</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_sync_trajectory(replacement_values)","title":"<code>replacement_values</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_sync_trajectory(max_steps)","title":"<code>max_steps</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.async_eval_next_state","title":"<code>grins.ising_bool.async_eval_next_state(prev_state, topo_adj, replacement_values, update_index)</code>","text":"<p>Asynchronously evaluates the next state of a node in an Ising model.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The previous state vector of the system.</p> required <code>ndarray</code> <p>The adjacency matrix representing the topology of the system.</p> required <code>ndarray</code> <p>A vector of two values used for state replacement based on conditions. The values of the vector should be [value_if_negative, value_if_positive]. The value for 0 is not included as it is assumed that the state will remain the same if the node evaluates to 0 in that step.</p> required <code>int</code> <p>The index of the node to update.</p> required <p>Returns:</p> Type Description <p>jnp.ndarray: The new state vector after updating the specified node.</p>"},{"location":"api/IsingBoolean/#grins.ising_bool.async_eval_next_state(prev_state)","title":"<code>prev_state</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.async_eval_next_state(topo_adj)","title":"<code>topo_adj</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.async_eval_next_state(replacement_values)","title":"<code>replacement_values</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.async_eval_next_state(update_index)","title":"<code>update_index</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_async_trajectory","title":"<code>grins.ising_bool.simulate_async_trajectory(initial_condition, topo_adj, replacement_values, update_indices)</code>","text":"<p>Simulates an asynchronous trajectory of a system given an initial condition and update indices.</p> <p>Parameters:</p> Name Type Description Default <code>array - like</code> <p>The initial condition of the network.</p> required <code>array - like</code> <p>The adjacency matrix of the network.</p> required <code>array - like</code> <p>The values used to replace the state of the nodes during updates. It is a vector of two values in the form [value_if_negative, value_if_positive].</p> required <code>array - like</code> <p>A vector of indices specifying which node to update at each step. Length of the vector should be equal to the number of steps, if not will only be run till the length of the update_indices.</p> required <p>Returns:</p> Type Description <p>jnp.ndarray: A 2D array where each row represents the state of the system at a given step,with the first column indicating the step number. The states are of dtype int16 and all -1 values are converted to 0 if the replacement values are [-1, 1].</p>"},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_async_trajectory(initial_condition)","title":"<code>initial_condition</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_async_trajectory(topo_adj)","title":"<code>topo_adj</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_async_trajectory(replacement_values)","title":"<code>replacement_values</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.simulate_async_trajectory(update_indices)","title":"<code>update_indices</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations","title":"<code>grins.ising_bool.run_simulations(topo_file, num_initial_conditions=None, inital_conditions=None, max_steps=None, batch_size=None, replacement_values=jnp.array([0, 1]), mode='sync', packbits=False, save_dir='IsingSimulResults')</code>","text":"<p>Run synchronous or asynchronous simulations for a given topology.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Path to the topology file.</p> required <code>int</code> <p>Number of initial conditions to sample.</p> <code>None</code> <code>ndarray</code> <p>Initial conditions matrix with the individual intial conditions as rows of the matrix. If provided, num_initial_conditions is ignored.</p> required <code>int</code> <p>Maximum number of steps to simulate. If not provided, it is calculated to be 10 times the number of nodes.</p> <code>None</code> <code>int</code> <p>Number of samples per batch.</p> <code>None</code> <code>ndarray</code> <p>Values used for replacement in the simulation. Default is [0, 1].</p> <code>array([0, 1])</code> <code>str</code> <p>Simulation mode, either \"sync\" or \"async\".</p> <code>'sync'</code> <code>bool</code> <p>Whether to pack the 0/1 states into bits to reduce memory usage. Uses jnp.packbits for packing.</p> <code>False</code> <code>str</code> <p>Directory to save the simulation results.</p> <code>'IsingSimulResults'</code> <p>Returns:</p> Type Description <p>None. The simulation results are saved to a parquet file in save_dir within a subdirectory named after the topology file.</p> <p>Example: Run the synchronous simulation for a topology file:</p> <p>'''python</p> <p>run_simulations( ...     topo_file=\"TOPOS/ER_1000_0.1.topo\", ...     num_initial_conditions=210, ...     max_steps=100, ...     batch_size=210, ...     replacement_values=jnp.array([0, 1]), ...     mode=\"sync\", ...     packbits=True, ...     save_dir=\"IsingSimulResults\", ... ) '''</p> <p>This will save the simulation results to a parquet file in the directory \"IsingSimulResults/ER_1000_0.1/ER_1000_0.1_sync_results.parquet\".</p> <p>Similary, the asynchronous simulation can be run by setting mode=\"async\".</p> <p>If the initial conditions matrix is provided, the num_initial_conditions parameter is ignored. In this case, the initial_conditions matrix should have the individual initial conditions as rows.</p>"},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(topo_file)","title":"<code>topo_file</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(num_initial_conditions)","title":"<code>num_initial_conditions</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(initial_conditions)","title":"<code>initial_conditions</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(max_steps)","title":"<code>max_steps</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(batch_size)","title":"<code>batch_size</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(replacement_values)","title":"<code>replacement_values</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(mode)","title":"<code>mode</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(packbits)","title":"<code>packbits</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations(save_dir)","title":"<code>save_dir</code>","text":""},{"location":"api/IsingBoolean/#grins.ising_bool.run_simulations--if-only-specfic-inital-conditions-are-to-be-used-the-initial-conditions-matrix-can-be-provided-with-the-individual-initial-conditions-as-rows-of-the-matrix-this-provides-control-over-simulating-specific-pre-defined-initial-conditions","title":"If only specfic inital conditions are to be used, the initial conditions matrix can be provided with the individual initial conditions as rows of the matrix. This provides control over simulating specific pre-defined initial conditions.","text":"<p>'''python</p> <p>initial_conditions = jnp.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 0, 1, 1]]) run_simulations( ...     topo_file=\"TOPOS/ER_1000_0.1.topo\", ...     initial_conditions=initial_conditions, ...     max_steps=100, ...     batch_size=2**10, ...     replacement_values=jnp.array([0, 1]), ...     mode=\"sync\", ...     packbits=True, ...     save_dir=\"IsingSimulResults\", ... ) '''</p> <p>For cases where the replacement values are not [0, 1], the replacement values should be provided as a jax array of length 2 with the first value less than the second.</p> <p>'''python</p> <p>replacement_values = jnp.array([-1, 1]) # Replacement values are -1 for negetive and 1 for positive run_simulations( ...     topo_file=\"TOPOS/ER_1000_0.1.topo\", ...     num_initial_conditions=210, ...     max_steps=100, ...     batch_size=210, ...     replacement_values=replacement_values, ...     mode=\"sync\", ...     packbits=True, ...     save_dir=\"IsingSimulResults\", ... ) '''</p> <p>The results for [-1, 1] replacment values will also be converted to 0 for all the -1 or 0 values in the states and 1s will remain as 1s when saving to the file. This is important as otherwise the packbits  would not work.</p> <p>The packbits function used is jnp.packbits which packs the 0/1 states into bits to reduce memory usage. This is useful when the number of nodes is large and the number of steps is also large. The memory usase can be reduced by a factor of 8 by packing the states into bits. If packbits is not set to True, the states are saved as is.</p> <p>'''python</p> <p>run_simulations( ...     topo_file=\"TOPOS/ER_1000_0.1.topo\", ...     num_initial_conditions=210, ...     max_steps=100, ...     batch_size=210, ...     replacement_values=jnp.array([0, 1]), ...     mode=\"sync\", ...     packbits=False, ...     save_dir=\"IsingSimulResults\", ... ) '''</p> <p>The final dataframe which is written to the parquet file has the following columns for the packbits=False case: - Step: The step number for the simulation. - Node names: The names of the nodes in the network. If the packbits=True, the final dataframe has the following columns: - Step: The step number for the simulation. - Byte_i: The ith byte of the packed states for the simulation. The Byte_i columns are created based on the number of nodes in the network. For example, if there are 100 nodes, there will be 13 columns for the packed states. They can be unpacked using jnp.unpackbits to get the unpacked state values. The order of the nodes for the Byte_i columns is the same as the order of the nodes in the network after parsing the topology file using the parse_topo_to_matrix function. The order of the nodes is saved in a text file in the simulation directory for easy reference. The naming convention for the text file is toponame_node_names_order.csv.</p>"},{"location":"api/RACIPE/","title":"RACIPE Formalism","text":"<p>Functions related to RACIPE simulation.</p>"},{"location":"api/RACIPE/#grn-parsing-and-ode-generation-functions","title":"GRN Parsing and ODE Generation Functions","text":""},{"location":"api/RACIPE/#grins.reg_funcs.psH","title":"<code>grins.reg_funcs.psH(nod, fld, thr, hill)</code>","text":"<p>Positive Shifted Hill function.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>The node expression value.</p> required <code>float</code> <p>The fold change.</p> required <code>float</code> <p>The half-maximal threshold value.</p> required <code>float</code> <p>The hill coefficient.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the Positive Shifted Hill function.</p>"},{"location":"api/RACIPE/#grins.reg_funcs.psH(nod)","title":"<code>nod</code>","text":""},{"location":"api/RACIPE/#grins.reg_funcs.psH(fld)","title":"<code>fld</code>","text":""},{"location":"api/RACIPE/#grins.reg_funcs.psH(thr)","title":"<code>thr</code>","text":""},{"location":"api/RACIPE/#grins.reg_funcs.psH(hill)","title":"<code>hill</code>","text":""},{"location":"api/RACIPE/#grins.reg_funcs.nsH","title":"<code>grins.reg_funcs.nsH(nod, fld, thr, hill)</code>","text":"<p>Negative Shifted Hill function.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>The node expression value.</p> required <code>float</code> <p>The fold change.</p> required <code>float</code> <p>The half-maximal threshold value.</p> required <code>float</code> <p>The hill coefficient.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the Negative Shifted Hill function.</p>"},{"location":"api/RACIPE/#grins.reg_funcs.nsH(nod)","title":"<code>nod</code>","text":""},{"location":"api/RACIPE/#grins.reg_funcs.nsH(fld)","title":"<code>fld</code>","text":""},{"location":"api/RACIPE/#grins.reg_funcs.nsH(thr)","title":"<code>thr</code>","text":""},{"location":"api/RACIPE/#grins.reg_funcs.nsH(hill)","title":"<code>hill</code>","text":""},{"location":"api/RACIPE/#grins.gen_diffrax_ode.gen_diffrax_odesys","title":"<code>grins.gen_diffrax_ode.gen_diffrax_odesys(topo_df, topo_name, save_dir='.')</code>","text":"<p>Generate the ODE system code for diffrax based on the given topology dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>The topology dataframe containing the edges information.</p> required <code>str</code> <p>The name of the topology.</p> required <code>str</code> <p>The directory to save the generated code. Defaults to \".\".</p> <code>'.'</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Saves the generated file in the driectory specified by save_dir.</p>"},{"location":"api/RACIPE/#grins.gen_diffrax_ode.gen_diffrax_odesys(topo_df)","title":"<code>topo_df</code>","text":""},{"location":"api/RACIPE/#grins.gen_diffrax_ode.gen_diffrax_odesys(topo_name)","title":"<code>topo_name</code>","text":""},{"location":"api/RACIPE/#grins.gen_diffrax_ode.gen_diffrax_odesys(save_dir)","title":"<code>save_dir</code>","text":""},{"location":"api/RACIPE/#parameters-and-intial-conditions-generation-functions","title":"Parameters and Intial Conditions Generation Functions","text":""},{"location":"api/RACIPE/#grins.gen_params.parse_topos","title":"<code>grins.gen_params.parse_topos(topofile, save_cleaned=False)</code>","text":"<p>Parse and cleans the given topofile and return the dataframe. It is expeced that the topo files is a tab-separated file with three columns: Source, Target, and Type. White spaces can also be used to separate the columns.</p> <p>For nodes that are not alphanumeric, the function will replace the non-alphanumeric characters with an underscore and prepend \"Node_\" if the node name does not start with an alphabet. The cleaned topology file will be saved if the save_cleaned flag is set to True.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The path to the topofile.</p> required <code>bool</code> <p>If True, save the cleaned topology file. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>topo_df</code> <code>DataFrame</code> <p>The parsed dataframe.</p>"},{"location":"api/RACIPE/#grins.gen_params.parse_topos(topofile)","title":"<code>topofile</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.parse_topos(save_cleaned)","title":"<code>save_cleaned</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.gen_param_names","title":"<code>grins.gen_params.gen_param_names(topo_df)</code>","text":"<p>Generate parameter names based on the given topology dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>The topology dataframe containing the information about the nodes and edges.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[List[str], List[str], List[str]]</code> <p>A tuple containing the parameter names, unique target node names, and unique source node names.</p>"},{"location":"api/RACIPE/#grins.gen_params.gen_param_names(topo_df)","title":"<code>topo_df</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.sample_distribution","title":"<code>grins.gen_params.sample_distribution(method, dimension, num_points, std_dev=None, optimise=False)</code>","text":"<p>Generates a sample distribution based on the specified method.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The sampling method to use. Options are \"Sobol\", \"LHS\", \"Uniform\", \"LogUniform\", \"Normal\", \"LogNormal\".</p> required <code>int</code> <p>The number of dimensions for the sample points.</p> required <code>int</code> <p>The number of sample points to generate.</p> required <code>Optional[float]</code> <p>The standard deviation for the \"Normal\" and \"LogNormal\" distributions. Defaults to 1.0 if not provided.</p> <code>None</code> <code>bool</code> <p>Whether to optimise the sampling process. Applicable for \"Sobol\" and \"LHS\" methods.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: An array of sample points generated according to the specified method.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown sampling method is specified.</p>"},{"location":"api/RACIPE/#grins.gen_params.sample_distribution(method)","title":"<code>method</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.sample_distribution(dimension)","title":"<code>dimension</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.sample_distribution(num_points)","title":"<code>num_points</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.sample_distribution(std_dev)","title":"<code>std_dev</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.sample_distribution(optimise)","title":"<code>optimise</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.gen_param_range_df","title":"<code>grins.gen_params.gen_param_range_df(topo_df, num_params=2 ** 10, sampling_method='Sobol', thr_rows=True)</code>","text":"<p>Generate a parameter range DataFrame from the topology DataFrame.</p> <pre><code>topo_df (pd.DataFrame): The topology DataFrame containing the network structure.\nnum_params (int, optional): The number of parameters to generate. Default is 1024.\nsampling_method (Union[str, dict], optional): The sampling method to use. Can be a string\n    specifying a single method for all parameters or a dictionary specifying methods for\n    individual parameters. Default is \"Sobol\".\nthr_rows (bool, optional): Whether to add threshold rows to the DataFrame. Default is True.\n</code></pre> <pre><code>pd.DataFrame: A DataFrame containing the parameter ranges and sampling methods.\n</code></pre>"},{"location":"api/RACIPE/#grins.gen_params.gen_param_df","title":"<code>grins.gen_params.gen_param_df(prange_df=None, num_params=2 ** 10, topo_df=None, sampling_method='Sobol', thr_rows=True)</code>","text":"<p>Generate the final parameter DataFrame by sampling parameters. Parameters are grouped by their 'Sampling' (and 'StdDev' if present) to ensure that parameters in the same group follow the same distribution in the higher dimensions. The final DataFrame columns are arranged in the same order as in prange_df. The sampling methods can be: 'Sobol', 'LHS', 'Uniform', 'LogUniform', 'Normal', 'LogNormal'.</p> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>DataFrame with columns [\"Parameter\", \"Minimum\", \"Maximum\", \"Sampling\", ...].</p> <code>None</code> <code>int</code> <p>Number of samples to generate per parameter.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame of sampled and scaled parameters.</p>"},{"location":"api/RACIPE/#grins.gen_params.gen_param_df(prange_df)","title":"<code>prange_df</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.gen_param_df(num_paras)","title":"<code>num_paras</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.gen_init_cond","title":"<code>grins.gen_params.gen_init_cond(topo_df, num_init_conds=1000)</code>","text":"<p>Generate initial conditions for each node based on the topology.</p> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>A DataFrame containing the topology information.</p> required <code>int</code> <p>The number of initial conditions to generate. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the generated initial conditions for each node.</p>"},{"location":"api/RACIPE/#grins.gen_params.gen_init_cond(topo_df)","title":"<code>topo_df</code>","text":""},{"location":"api/RACIPE/#grins.gen_params.gen_init_cond(num_init_conds)","title":"<code>num_init_conds</code>","text":""},{"location":"api/RACIPE/#simulation-related-functions","title":"Simulation Related Functions","text":""},{"location":"api/RACIPE/#grins.racipe_run.gen_sim_dirstruct","title":"<code>grins.racipe_run.gen_sim_dirstruct(topo_file, save_dir='.', num_replicates=3)</code>","text":"<p>Generate directory structure for simulation run.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Path to the topo file.</p> required <code>str</code> <p>Directory to save the generated structure. Defaults to \".\".</p> <code>'.'</code> <code>int</code> <p>Number of replicates to generate. Defaults to 3.</p> <code>3</code> <p>Returns:     Directory structure is created with the topo file name and three folders for the replicates.</p>"},{"location":"api/RACIPE/#grins.racipe_run.gen_sim_dirstruct(topo_file)","title":"<code>topo_file</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gen_sim_dirstruct(save_dir)","title":"<code>save_dir</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gen_sim_dirstruct(num_replicates)","title":"<code>num_replicates</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gen_topo_param_files","title":"<code>grins.racipe_run.gen_topo_param_files(topo_file, save_dir='.', num_replicates=3, num_params=2 ** 10, num_init_conds=2 ** 7, sampling_method='Sobol')</code>","text":"<p>Generate parameter files for simulation.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The path to the topo file.</p> required <code>str</code> <p>The directory where the parameter files will be saved. Defaults to \".\".</p> <code>'.'</code> <code>int</code> <p>The number of parameter files to generate. Defaults to 2**10.</p> <code>2 ** 10</code> <code>int</code> <p>The number of initial condition files to generate. Defaults to 2**7.</p> <code>2 ** 7</code> <code>Union[str, dict]</code> <p>The method to use for sampling the parameter space. Defaults to 'Sobol'. For a finer control over the parameter generation look at the documentation of the gen_param_range_df function and gen_param_df function.</p> <code>'Sobol'</code> <p>Returns:     The parameter files and initial conditions are generated and saved in the specified replicate directories.</p>"},{"location":"api/RACIPE/#grins.racipe_run.gen_topo_param_files(topo_file)","title":"<code>topo_file</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gen_topo_param_files(save_dir)","title":"<code>save_dir</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gen_topo_param_files(num_params)","title":"<code>num_params</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gen_topo_param_files(num_init_conds)","title":"<code>num_init_conds</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gen_topo_param_files(sampling_method)","title":"<code>sampling_method</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.load_odeterm","title":"<code>grins.racipe_run.load_odeterm(topo_name, simdir)</code>","text":"<p>Loads an ODE system from a specified topology module and returns an ODETerm object.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the topology module to import.</p> required <code>str</code> <p>The directory path where the topology module is located.</p> required <p>Returns:</p> Name Type Description <code>ODETerm</code> <p>An object representing the ODE system.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the specified module cannot be imported.</p> <code>AttributeError</code> <p>If the module does not contain an attribute named 'odesys'.</p>"},{"location":"api/RACIPE/#grins.racipe_run.load_odeterm(topo_name)","title":"<code>topo_name</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.load_odeterm(simdir)","title":"<code>simdir</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate","title":"<code>grins.racipe_run.topo_simulate(topo_file, replicate_dir, initial_conditions, parameters, t0=0.0, tmax=200.0, dt0=0.01, tsteps=None, rel_tol=1e-05, abs_tol=1e-06, max_steps=2048, batch_size=10000, ode_term_dir=None)</code>","text":"<p>Simulates the ODE system defined by the topology file and saves the results in the replicate directory. The ode system is loaded as a diffrax ode term and the initial conditions and parameters are passed as jax arrays. The simulation is run for the specified time range and time steps and the results are saved in parquet format in the replicate directory.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Path to the topology file.</p> required <code>str</code> <p>Directory where the replicate results will be saved.</p> required <code>DataFrame</code> <p>DataFrame containing the initial conditions.</p> required <code>DataFrame</code> <p>DataFrame containing the parameters.</p> required <code>float</code> <p>Initial time for the simulation. Default is 0.0.</p> <code>0.0</code> <code>float</code> <p>Maximum time for the simulation. Default is 100.0.</p> <code>200.0</code> <code>float</code> <p>Initial time step size. Default is 0.1.</p> <code>0.01</code> <code>list</code> <p>List of time steps at which to save the results. Default is None.</p> <code>None</code> <code>float</code> <p>Relative tolerance for the ODE solver. Default is 1e-5.</p> <code>1e-05</code> <code>float</code> <p>Absolute tolerance for the ODE solver. Default is 1e-6.</p> <code>1e-06</code> <code>int</code> <p>Maximum number of steps for the ODE solver. Default is 2048.</p> <code>2048</code> <code>int</code> <p>Batch size for processing combinations of initial conditions and parameters. Default is 10000.</p> <code>10000</code> <code>str</code> <p>Directory where the ODE system file is located. Default is None. If None, the parent directory of the replicate directory is assumed to contain the ODE system file. The ODE system file should be named as the topo file with the .py extension.</p> <code>None</code> <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame containing the solutions of the ODE system.</p>"},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(topo_file)","title":"<code>topo_file</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(replicate_dir)","title":"<code>replicate_dir</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(initial_conditions)","title":"<code>initial_conditions</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(parameters)","title":"<code>parameters</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(t0)","title":"<code>t0</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(tmax)","title":"<code>tmax</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(dt0)","title":"<code>dt0</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(tsteps)","title":"<code>tsteps</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(rel_tol)","title":"<code>rel_tol</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(abs_tol)","title":"<code>abs_tol</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(max_steps)","title":"<code>max_steps</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(batch_size)","title":"<code>batch_size</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.topo_simulate(ode_term_dir)","title":"<code>ode_term_dir</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gk_normalise_solutions","title":"<code>grins.racipe_run.gk_normalise_solutions(sol_df, param_df, threshold=1.01, discretize=True)</code>","text":"<p>Normalises the solutions in the solution dataframe using the maximum production rate (G) and degradation rate (k) parameters of the individual nodes in the parameter sets.</p> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>DataFrame containing the solutions with a 'ParamNum' column to join with param_df.</p> required <code>DataFrame</code> <p>DataFrame containing the parameters with 'Prod_' and 'Deg_' columns for each node.</p> required <code>float</code> <p>Threshold value for discretising the solutions. Default is 1.01.</p> <code>1.01</code> <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame with normalised and discretized solutions.</p> <p>pd.DataFrame: A DataFrame containing the counts of each state in the normalised solutions</p> <p>Example: First, run the simulation then, normalise and discretise the solutions</p> <p>'''python</p> <p>sol_df, state_counts = gk_normalise_solutions(sol_df, params) '''</p> <p>Here, the 'sol_df' is the solution dataframe and 'params' is the parameter dataframe. The 'state_counts' dataframe contains the counts of each state in the normalised solutions. The returned 'sol_df' is the normalised and discretised solution dataframe.</p>"},{"location":"api/RACIPE/#grins.racipe_run.gk_normalise_solutions(sol_df)","title":"<code>sol_df</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gk_normalise_solutions(param_df)","title":"<code>param_df</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.gk_normalise_solutions(threshold)","title":"<code>threshold</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.discretise_solutions","title":"<code>grins.racipe_run.discretise_solutions(norm_df, threshold=1.01)</code>","text":"<p>Discretises the solutions in a g/k normalized DataFrame based on histogram peaks and minima.</p> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>A DataFrame containing normalized values to be discretised.</p> required <code>float</code> <p>A hard threshold value to clip the values in the DataFrame. Default is 1.01. Ih the parameter sets are in such a way that the maximum possible expression of the node is not prduction/degradation, then the threshold value needs to be adjusted accordingly.</p> <code>1.01</code> <p>Returns:</p> Type Description <p>pd.Series: A Series containing the discrete state labels for each row in the input DataFrame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any value in the DataFrame exceeds the specified threshold.</p> <p>Example: Given a normalized DataFrame 'norm_df', discretise the values</p> <p>'''python</p> <p>lvl_df = discretise_solutions(norm_df) '''</p> <p>The normalised solution dataframe will have vlaues of the nodes bewteen 0 (lowest) and 1 (highest) and the returned 'lvl_df' will have the discrete state labels for each row in the input DataFrame.</p>"},{"location":"api/RACIPE/#grins.racipe_run.discretise_solutions(norm_df)","title":"<code>norm_df</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.discretise_solutions(threshold)","title":"<code>threshold</code>","text":""},{"location":"api/RACIPE/#grins.racipe_run.run_all_replicates","title":"<code>grins.racipe_run.run_all_replicates(topo_file, save_dir='.', t0=0.0, tmax=200.0, dt0=0.01, tsteps=None, rel_tol=1e-05, abs_tol=1e-06, max_steps=2048, batch_size=10000, normalize=True, discretize=True)</code>","text":"<p>Run simulations for all replicates of the specified topo file. The initial conditions and parameters are loaded from the replicate folders. The directory structure is assumed to be the same as that generated by the gen_topo_param_files function, with the main directory with the topo file name which has the parameter range file the ODE system file and the replicate folders with the initial conditions and parameters dataframes.</p> <p>Parameters: topo_file (str): Path to the topology file. save_dir (str, optional): Directory where the replicate folders are saved. Defaults to \".\". t0 (float, optional): Initial time for the simulation. Defaults to 0.0. tmax (float, optional): Maximum time for the simulation. Defaults to 100.0. dt0 (float, optional): Initial time step for the simulation. Defaults to 0.1. tsteps (int, optional): Number of time steps for the simulation. Defaults to None. rel_tol (float, optional): Relative tolerance for the simulation. Defaults to 1e-5. abs_tol (float, optional): Absolute tolerance for the simulation. Defaults to 1e-6. max_steps (int, optional): Maximum number of steps for the simulation. Defaults to 2048. batch_size (int, optional): Batch size for the simulation. Defaults to 1000. normalize (bool, optional): Whether to normalise the solutions. Defaults to True. discretize (bool, optional): Whether to discretize the solutions. Defaults to True.</p> <p>Returns: None</p> <p>Note: The results of the simulation are saved in the replicate folders in the specified directory. If the simulation is time series, the results are saved as 'timeseries_solutions.parquet' and if the simulation is steady state, the results are saved as 'steadystate_solutions.parquet'.</p> <p>Normalisation and discretisation of the solutions are optional. But to discretise the solutions, the normalisation is required.</p> <p>If the discretize flag is set to True, the solutions are discretized and the state counts are saved as 'state_counts.csv', this is only applicable for steady state simulations. If the discretize flag is set to False, the solutions are normalised but not discretized.</p> <p>Example: Run the simulation for the specified topo file</p> <p>'''python</p> <p>run_all_replicates(topo_file, save_dir, t0, tmax, dt0, tsteps, rel_tol, abs_tol, max_steps, batch_size) '''</p>"},{"location":"usage/Ising_Tutorial/","title":"Ising Boolean GRN Simulation Tutorial","text":""},{"location":"usage/Ising_Tutorial/#overview","title":"Overview","text":"<p>This tutorial explains the pipeline for running Boolean simulations on gene regulatory networks (GRNs). The script processes topology files and runs simulations using different modes (synchronous and asynchronous).</p>"},{"location":"usage/Ising_Tutorial/#step-1-define-the-topology-file-directory","title":"Step 1: Define the Topology File Directory","text":"<p>We first specify the directory containing the topology files. These files define the network structure and interactions between genes.</p> <pre><code># Specify the path to the topo file\ntopo_folder = \"TOPOS\"\n</code></pre>"},{"location":"usage/Ising_Tutorial/#step-2-retrieve-topology-files","title":"Step 2: Retrieve Topology Files","text":"<p>We retrieve all topology files from the specified directory using the <code>glob</code> module. The files are sorted to ensure a consistent processing order - this sorting is not necessary.</p> <pre><code># Get the list of all the topo files\ntopo_files = sorted(glob.glob(f\"{topo_folder}/*.topo\"))\nprint(topo_files)\n</code></pre>"},{"location":"usage/Ising_Tutorial/#step-3-define-simulation-parameters","title":"Step 3: Define Simulation Parameters","text":"<p>Before running the simulations, we specify key parameters that control the simulation behavior:</p> <ul> <li>Replacement Values: The Boolean states (0 and 1) used in the simulation. Can also be (-1 and 1).</li> <li>Number of Steps: The total number of steps to simulate.</li> <li>Number of Initial Conditions: The number of different initial conditions to explore.</li> <li>Batch Size: The batch size for the simualtions, depends on the VRAM of the GPU, the function uses 'vmap' of jax to run each batch.</li> </ul> <pre><code># Specify the replacement values\nreplacement_values = jnp.array([0, 1])\n\n# Specify the number of steps to simulate\nmax_steps = 100\nprint(f\"Number of steps: {max_steps}\")\n\n# Specify the number of initial conditions to simulate\nnum_initial_conditions = 2**14\nprint(f\"Number of initial conditions: {num_initial_conditions}\")\n\n# Specify the batch size for parallel evaluation\nbatch_size = 2**10\n</code></pre>"},{"location":"usage/Ising_Tutorial/#step-4-process-topology-files-and-run-simulations","title":"Step 4: Process Topology Files and Run Simulations","text":"<p>We loop through each topology file, extract the adjacency matrix, and run simulations in both synchronous and asynchronous modes.</p> <pre><code># Loop over all the topo files\nfor topo_file in topo_files:\n    # Get the adjacency matrix and node names\n    topo_adj, node_names = parse_topo_to_matrix(topo_file)\n    print(f\"Topology: {topo_file}\")\n\n    # Run the simulation in synchronous mode\n    run_simulations(\n        topo_file=topo_file,\n        num_initial_conditions=num_initial_conditions,\n        batch_size=batch_size,\n        replacement_values=replacement_values,\n        mode=\"sync\",\n        packbits=True,\n    )\n\n    # Run the simulation in asynchronous mode\n    run_simulations(\n        topo_file=topo_file,\n        num_initial_conditions=num_initial_conditions,\n        batch_size=batch_size,\n        replacement_values=replacement_values,\n        mode=\"async\",\n        packbits=True,\n    )\n</code></pre> <p>The simulation results will be stored in the output directory, with each topology file having its own dedicated folder within the simulation directory. This folder will contain the results saved as a Parquet file named '__ising_results.parquet'. For further customization options, refer to the 'run_simulations' function."},{"location":"usage/RACIPE_Tutorial/","title":"RACIPE Simulations Tutorial","text":""},{"location":"usage/RACIPE_Tutorial/#overview","title":"Overview","text":"<p>This tutorial provides a comprehensive pipeline that integrates various functions for RACIPE simulations from the 'grins' library. It guides you through generating the ODE system file, parameter sets, and initial conditions, ultimately running simulations for all topology files in a specified directory containing gene regulatory network topologies.</p> <p>If more customization is needed, a similar pipeline can be built using the custom functions provided in the package\u2014this tutorial serves as a guide for structuring such workflows.</p>"},{"location":"usage/RACIPE_Tutorial/#step-1-define-the-number-if-parallel-cores-to-use","title":"Step 1: Define the number if parallel cores to use","text":"<p>We first specify the number of CPU cores to use for parallel execution. While this step is not mandatory, it significantly speeds up the parameter and initial condition generation process, making the pipeline more efficient if one is simulating a large number of networks.</p> <pre><code>numCores = 15\nprint(f\"Number of cores: {numCores}\")\n</code></pre>"},{"location":"usage/RACIPE_Tutorial/#step-2-define-directories","title":"Step 2: Define Directories","text":"<p>We define the input and output directories to organize the topology files and simulation results efficiently. The topology files, which describe the structure of gene regulatory networks, are stored in a dedicated directory ('TOPOS'). The simulation results, including generated parameter sets, initial conditions, and computed outputs, are saved in a separate directory ('SimulResults').</p> <p>Before proceeding, we ensure that the output directory exists by using 'os.makedirs(sim_save_dir, exist_ok=True)'. This command creates the directory if it does not already exist.</p> <pre><code>import os\nfrom glob import glob\n\n# Topology file directory\ntopo_dir = \"TOPOS\"\n# Directory to store simulation results\nsim_save_dir = \"SimulResults\"\n# Create output directory if it does not exist\nos.makedirs(sim_save_dir, exist_ok=True)\n</code></pre>"},{"location":"usage/RACIPE_Tutorial/#step-3-load-topology-files","title":"Step 3: Load Topology Files","text":"<p>We retrieve all topology files that need to be simulated.</p> <p>The 'glob' function is used to search for all files with a '.topo' extension in the specified directory ('topo_dir'). The 'sorted()' function ensures that the files are processed in a the alphbetical oder, but this is not necessary.</p> <pre><code># Get the list of all topology files which need to be simulated\ntopo_files = sorted(glob(f\"{topo_dir}/*.topo\"))\nprint(f\"Number of topology files: {len(topo_files)}\")\n</code></pre>"},{"location":"usage/RACIPE_Tutorial/#step-4-define-simulation-parameters","title":"Step 4: Define Simulation Parameters","text":"<p>Specify the number of replicates per topology file, the number of parameter sets to generate, and the number of initial conditions to be generated. These values determine the scale of the simulation:</p> <ul> <li>Replicates per topology file: The number of times each topology file will be simulated to account for variability.</li> <li>Parameter sets: The number of different sets of parameters to generate for each topology file.</li> <li>Initial conditions: The number of different initial conditions to be considered for each parameter set.</li> </ul> <p>The simulations will be run for all combinations of initial conditions and parameter sets. The standard deviation of the measured metric across all replicates is a useful indicator of how well the chosen number of parameters and initial conditions capture the dynamics of the gene regulatory network (GRN). If the standard deviation is high, increasing the number of parameter sets or initial conditions may improve the robustness of the results.</p> <pre><code>num_replicates = 3\nnum_params = 10000\nnum_init_conds = 100\nprint(f\"Number of replicates: {num_replicates}\")\nprint(f\"Number of parameters: {num_params}\")\nprint(f\"Number of initial conditions: {num_init_conds}\\n\")\n</code></pre>"},{"location":"usage/RACIPE_Tutorial/#step-5-parallelized-parameter-and-initial-condition-generation","title":"Step 5: Parallelized Parameter and Initial Condition Generation","text":"<p>We use multiprocessing to generate parameter and initial condition files in parallel. This setp is not necessary, but will significantly speed up the paramter sets and intial conditions generation time when simulating large number of networks.</p> <pre><code>from multiprocessing import Pool\n\n# Start multiprocessing pool\npool = Pool(numCores)\nprint(\"Generating Parameter and Initial Condition files...\")\n\n# Parallel execution of file generation\npool.starmap(\n    gen_topo_param_files,\n    [\n        (\n            topo_file,\n            sim_save_dir,\n            num_replicates,\n            num_params,\n            num_init_conds,\n        )\n        for topo_file in topo_files\n    ],\n)\nprint(\"Parameter and Initial Condition files generated.\\n\")\n\n# Close multiprocessing pool\npool.close()\n</code></pre>"},{"location":"usage/RACIPE_Tutorial/#step-6-running-simulations","title":"Step 6: Running Simulations","text":"<p>Once parameter files are generated, we run simulations for each topology file.</p> <pre><code>import jax.numpy as jnp\n\nfor topo_file in topo_files:\n    # Generate parameters using Sobol sampling (optional - if the paramters are not already generated in parallel)\n    gen_topo_param_files(\n        topo_file,\n        sim_save_dir,\n        num_replicates,\n        num_params,\n        num_init_conds,\n        sampling_method=\"Sobol\",\n    )\n\n    # Run time-series simulations\n    run_all_replicates(\n        topo_file,\n        sim_save_dir,\n        tsteps=jnp.array([25.0, 75.0, 100.0]),\n        max_steps=2048,\n    )\n\n    # Run steady-state simulations\n    run_all_replicates(\n        topo_file,\n        sim_save_dir,\n    )\n</code></pre> <p>The results of the simulations will be stored in the sim_save_dir, with each topology file having its own dedicated folder named after the topology file. Within these folders, the following structure will be maintained:</p>"},{"location":"usage/RACIPE_Tutorial/#topology-file-and-ode-system","title":"Topology File and ODE System","text":"<ul> <li>The original topology (.topo) file.</li> <li>The generated ODE system function using diffrax, which is created by parsing the topology file.</li> </ul>"},{"location":"usage/RACIPE_Tutorial/#replicate-subdirectories","title":"Replicate Subdirectories","text":"<p>Each topology folder will contain multiple replicate subdirectories (one per replicate). These will store:     -   Initial Conditions: Saved as a Parquet file ('init_conds.parquet').     -   Parameter Sets: Stored in another Parquet file ('params.parquet').     -   Parameter Range: A CSV file (parameter_range.csv) defining the parameter bounds before the simulation is run."},{"location":"usage/RACIPE_Tutorial/#simulation-output-files","title":"Simulation Output Files","text":"<p>Once the simulations are completed, the solution files will be stored in the respective replicate folders. Depending on the simulation type, the output files will follow these naming conventions:     -   Steady-state solutions: 'steady_state_solutions.parquet'     -   Time-series solutions: 'time_series_solutions.parquet'     -   Discretized State Data (if applicable): If the user has opted to discretize the states, an additional file will be present containing the unique states and their occurrence counts."},{"location":"usage/racipe/","title":"RACIPE","text":"<p>Simulates ODEs for a given network topology for over different parameter sets and initial conditions and outputs the steady state values.</p>"},{"location":"usage/racipe/#usage","title":"Usage","text":"<p>The <code>racipe</code> command can be used with the following options:</p>"},{"location":"usage/racipe/#default-usage","title":"Default usage:","text":"<p>Generate parameters and initial conditions by randomly sampling from sobol sequences within the default range. Solve ODEs for each parameter set and initial condition, and output the steady state values.</p> <pre><code>racipe --topodir &lt;topo_dir&gt; --outdir &lt;output_dir&gt; --num_params &lt;num_params&gt; --num_inits &lt;num_inits&gt; --num_reps &lt;num_reps&gt; --num_cores &lt;num_cores&gt;\n</code></pre> <p>Parameters:     - <code>topodir</code>: Directory containing the network topology files. Default is <code>./TOPOS</code>.     - <code>outdir</code>: Directory to save the output files. Default is <code>./SimResults</code>.     - <code>num_params</code>: Number of parameter sets to generate. Default is 10000.     - <code>num_inits</code>: Number of initial conditions to generate. Default is 1000.     - <code>num_reps</code>: Number of repetitions for each parameter set and initial condition. Default is 3.     - <code>num_cores</code>: Number of cores to use for parallel processing. Default is all available cores. (Note: This option does nothing when a GPU is present and grins[cuda12] version is installed.)</p>"}]}