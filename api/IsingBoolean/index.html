
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="GRiNS: Gene Regulatory Interaction Network Simulator Documentation">
      
      
      
        <link rel="canonical" href="https://MoltenEcdysone09.github.io/GRiNS/api/IsingBoolean/">
      
      
        <link rel="prev" href="../RACIPE/">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.7">
    
    
      
        <title>Ising Boolean - GRiNS</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#ising-boolean-formalism" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="GRiNS" class="md-header__button md-logo" aria-label="GRiNS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            GRiNS
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Ising Boolean
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/MoltenEcdysone09/GRiNS" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    MoltenEcdysone09/GRiNS
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="GRiNS" class="md-nav__button md-logo" aria-label="GRiNS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    GRiNS
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/MoltenEcdysone09/GRiNS" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    MoltenEcdysone09/GRiNS
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Usage
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Usage
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/racipe/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RACIPE
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/Ising_Tutorial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ising Boolean GRN Simulation Tutorial
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/RACIPE_Tutorial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RACIPE Simulations Tutorial
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    API
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            API
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RACIPE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RACIPE
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Ising Boolean
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Ising Boolean
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#grn-parsing-and-inital-condition-generation-functions" class="md-nav__link">
    <span class="md-ellipsis">
      GRN Parsing and Inital Condition Generation Functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.ising_bool.parse_topo_to_matrix" class="md-nav__link">
    <span class="md-ellipsis">
      parse_topo_to_matrix
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.ising_bool.generate_intial_conditions" class="md-nav__link">
    <span class="md-ellipsis">
      generate_intial_conditions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ising-boolean-simulation-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Ising Boolean Simulation Functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.ising_bool.sync_eval_next_state" class="md-nav__link">
    <span class="md-ellipsis">
      sync_eval_next_state
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.ising_bool.simulate_sync_trajectory" class="md-nav__link">
    <span class="md-ellipsis">
      simulate_sync_trajectory
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.ising_bool.async_eval_next_state" class="md-nav__link">
    <span class="md-ellipsis">
      async_eval_next_state
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.ising_bool.simulate_async_trajectory" class="md-nav__link">
    <span class="md-ellipsis">
      simulate_async_trajectory
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.ising_bool.run_simulations" class="md-nav__link">
    <span class="md-ellipsis">
      run_simulations
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="ising-boolean-formalism">Ising Boolean Formalism</h1>
<p>Functions related to Ising simulation.</p>
<h2 id="grn-parsing-and-inital-condition-generation-functions">GRN Parsing and Inital Condition Generation Functions</h2>
<!-- ------- -->


<div class="doc doc-object doc-function">


<h2 id="grins.ising_bool.parse_topo_to_matrix" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">ising_bool</span><span class="o">.</span><span class="n">parse_topo_to_matrix</span><span class="p">(</span><span class="n">topofile_path</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Parses a topology file into an adjacency matrix.</p>
<p>This function reads a topology file, and converts it into an adjacency matrix.
The adjacency matrix is then converted to a JAX array.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>topofile_path</code></b>
              (<code><span title="str">str</span></code>)
          –
          <div class="doc-md-description">
            <p>The path to the topology file. The file should be in a format readable by pandas <code>read_csv</code> with whitespace as the delimiter.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="tuple">tuple</span></code>
          –
          <div class="doc-md-description">
            <p>A tuple containing:
topo_adj : jax.numpy.ndarray
    The adjacency matrix as a JAX array.
node_names : list
    A list of node names in the order they appear in the adjacency matrix.</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>grins/ising_bool.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">parse_topo_to_matrix</span><span class="p">(</span><span class="n">topofile_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses a topology file into an adjacency matrix.</span>

<span class="sd">    This function reads a topology file, and converts it into an adjacency matrix.</span>
<span class="sd">    The adjacency matrix is then converted to a JAX array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topofile_path : str</span>
<span class="sd">        The path to the topology file. The file should be in a format readable by pandas `read_csv` with whitespace as the delimiter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">        topo_adj : jax.numpy.ndarray</span>
<span class="sd">            The adjacency matrix as a JAX array.</span>
<span class="sd">        node_names : list</span>
<span class="sd">            A list of node names in the order they appear in the adjacency matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read the topo file as a pandas dataframe</span>
    <span class="n">topo_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">topofile_path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="p">)</span>
    <span class="c1"># Get the node names</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
    <span class="p">)</span>
    <span class="c1"># Adding self loops with type 0 for all the nodes if self loop of that node is not present</span>
    <span class="c1"># This is done to ensure that the adjacency matrix is square i.e all the only target or source nodes are also included</span>
    <span class="c1"># Subsetting the dataframe to get the self loops</span>
    <span class="n">self_loops</span> <span class="o">=</span> <span class="n">topo_df</span><span class="p">[</span><span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Source&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]]</span>
    <span class="c1"># Getting the list of nodes without self loops</span>
    <span class="n">nodes_without_self_loops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_names</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">self_loops</span><span class="p">[</span><span class="s2">&quot;Source&quot;</span><span class="p">]))</span>
    <span class="c1"># Creating a dataframe for the nodes without self loops</span>
    <span class="n">self_loops_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">nodes_without_self_loops</span><span class="p">,</span>
            <span class="n">nodes_without_self_loops</span><span class="p">,</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_without_self_loops</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># Renaming the columns</span>
    <span class="n">self_loops_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Source&quot;</span><span class="p">,</span> <span class="s2">&quot;Target&quot;</span><span class="p">,</span> <span class="s2">&quot;Type&quot;</span><span class="p">]</span>
    <span class="c1"># Adding the self loops to the topo dataframe</span>
    <span class="n">topo_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">topo_df</span><span class="p">,</span> <span class="n">self_loops_df</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Convert the type column to float</span>
    <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># Replacing the 2s with -1s</span>
    <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="mi">2</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">})</span>
    <span class="c1"># Pivot the dataframe to get the adjacencey matrix</span>
    <span class="n">topo_df</span> <span class="o">=</span> <span class="n">topo_df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;Source&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;Target&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s2">&quot;Type&quot;</span><span class="p">)</span>
    <span class="c1"># Make the node names set into a list</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node_names</span><span class="p">))</span>
    <span class="c1"># Reorder the columns and rows</span>
    <span class="n">topo_df</span> <span class="o">=</span> <span class="n">topo_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">node_names</span><span class="p">,</span> <span class="n">node_names</span><span class="p">]</span>
    <span class="c1"># Replace the NaN values with 0s</span>
    <span class="n">topo_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Convert the dataframe to a numpy adjacency matrix</span>
    <span class="n">topo_adj</span> <span class="o">=</span> <span class="n">topo_df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="c1"># Convert the adjacency matrix to a jax array</span>
    <span class="n">topo_adj</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">topo_adj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">topo_adj</span><span class="p">,</span> <span class="n">node_names</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.ising_bool.generate_intial_conditions" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">ising_bool</span><span class="o">.</span><span class="n">generate_intial_conditions</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generate initial conditions for a given number of nodes and samples.</p>
<p>This function generates initial conditions using Sobol sequences and scales the generated samples to [0, 1].</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>num_nodes</code></b>
              (<code><span title="int">int</span></code>)
          –
          <div class="doc-md-description">
            <p>The number of nodes for which to generate initial conditions.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>num_samples</code></b>
              (<code><span title="int">int</span></code>)
          –
          <div class="doc-md-description">
            <p>The number of samples to generate.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="jax.numpy.ndarray">ndarray</span></code>
          –
          <div class="doc-md-description">
            <p>The generated initial conditions as a JAX array of integers.</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>grins/ising_bool.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_intial_conditions</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate initial conditions for a given number of nodes and samples.</span>

<span class="sd">    This function generates initial conditions using Sobol sequences and scales the generated samples to [0, 1].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_nodes : int</span>
<span class="sd">        The number of nodes for which to generate initial conditions.</span>
<span class="sd">    num_samples : int</span>
<span class="sd">        The number of samples to generate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jax.numpy.ndarray</span>
<span class="sd">        The generated initial conditions as a JAX array of integers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Internal function to generate sobol sequences</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_gen_sobol_seq</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">optimise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate Sobol sequence samples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dimensions : int</span>
<span class="sd">            The number of dimensions for the Sobol sequence.</span>
<span class="sd">        num_samples : int</span>
<span class="sd">            The number of samples to generate.</span>
<span class="sd">        optimise : bool, optional</span>
<span class="sd">            Whether to use optimization for generation. Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The generated Sobol sequence samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">optimise</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">qmc</span><span class="o">.</span><span class="n">Sobol</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">scramble</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Optimisation leads to a significant slowdown in the generation</span>
            <span class="c1"># Use only if needed</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">qmc</span><span class="o">.</span><span class="n">Sobol</span><span class="p">(</span>
                <span class="n">d</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">scramble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimization</span><span class="o">=</span><span class="s2">&quot;lloyd&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span>

    <span class="c1"># Function which scales a given distribution to the required ranges</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_scale_distribution</span><span class="p">(</span>
        <span class="n">sample</span><span class="p">,</span>
        <span class="n">minmax_vals</span><span class="p">,</span>
        <span class="n">round_int</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale the given distribution to the required ranges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample : numpy.ndarray</span>
<span class="sd">            The distribution to be scaled.</span>
<span class="sd">        minmax_vals : tuple</span>
<span class="sd">            The minimum and maximum values for scaling.</span>
<span class="sd">        round_int : bool, optional</span>
<span class="sd">            Whether to round the values to the nearest integer. Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The scaled distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_vals</span> <span class="o">=</span> <span class="n">minmax_vals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">max_vals</span> <span class="o">=</span> <span class="n">minmax_vals</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">round_int</span><span class="p">:</span>
            <span class="n">min_vals</span> <span class="o">=</span> <span class="n">min_vals</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Scaling the values for the log distributions</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">min_vals</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_vals</span> <span class="o">-</span> <span class="n">min_vals</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">sample</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># If round is required, return the scaled and rounded values</span>
        <span class="k">if</span> <span class="n">round_int</span><span class="p">:</span>
            <span class="c1"># Rounding the values to the next integer</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
            <span class="c1"># # If values are present below the minimum value, shift them to the minimum value</span>
            <span class="c1"># If values are present above the maximum value, shift them to the maximum value</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">min_vals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_vals</span><span class="p">)</span>
            <span class="c1"># # Convert the values to integers</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sample</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sample</span>

    <span class="c1"># Generate the MinMax values</span>
    <span class="n">minmax_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">num_nodes</span><span class="p">)</span>
    <span class="c1"># Generate the Sobol sequences</span>
    <span class="n">unscaled_samples</span> <span class="o">=</span> <span class="n">_gen_sobol_seq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minmax_vals</span><span class="p">),</span> <span class="n">num_samples</span><span class="p">)</span>
    <span class="c1"># Scaling the samples</span>
    <span class="n">scaled_samples</span> <span class="o">=</span> <span class="n">_scale_distribution</span><span class="p">(</span>
        <span class="n">unscaled_samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">minmax_vals</span><span class="p">),</span> <span class="n">round_int</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="c1"># COnvert the jax array</span>
    <span class="n">scaled_samples</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scaled_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scaled_samples</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h2 id="ising-boolean-simulation-functions">Ising Boolean Simulation Functions</h2>


<div class="doc doc-object doc-function">


<h2 id="grins.ising_bool.sync_eval_next_state" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">ising_bool</span><span class="o">.</span><span class="n">sync_eval_next_state</span><span class="p">(</span><span class="n">prev_state</span><span class="p">,</span> <span class="n">topo_adj</span><span class="p">,</span> <span class="n">replacement_values</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Evaluate the next state of a system synchronously based on the previous state,
topology adjacency matrix, and replacement values.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>prev_state</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The previous state of the system.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>topo_adj</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The topology adjacency matrix representing the connections between nodes in the system.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>replacement_values</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>A vector of two values used for replacement based on the computed state conditions. The values are: [value_if_negative, value_if_positive].
Value of 0 is not included as it is assumed that the state will remain the same if the node evaluates to 0 in that step.
prev_state (jnp.ndarray): The previous state of the system.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="jax.numpy.ndarray">ndarray</span></code>
          –
          <div class="doc-md-description">
            <p>The new state of the system as an array of int16.</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>grins/ising_bool.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sync_eval_next_state</span><span class="p">(</span>
    <span class="n">prev_state</span><span class="p">,</span>
    <span class="n">topo_adj</span><span class="p">,</span>
    <span class="n">replacement_values</span><span class="p">,</span>  <span class="c1"># Vector of three values</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the next state of a system synchronously based on the previous state,</span>
<span class="sd">    topology adjacency matrix, and replacement values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prev_state : jnp.ndarray</span>
<span class="sd">        The previous state of the system.</span>
<span class="sd">    topo_adj : jnp.ndarray</span>
<span class="sd">        The topology adjacency matrix representing the connections between nodes in the system.</span>
<span class="sd">    replacement_values : jnp.ndarray</span>
<span class="sd">        A vector of two values used for replacement based on the computed state conditions. The values are: [value_if_negative, value_if_positive].</span>
<span class="sd">        Value of 0 is not included as it is assumed that the state will remain the same if the node evaluates to 0 in that step.</span>
<span class="sd">        prev_state (jnp.ndarray): The previous state of the system.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.ndarray</span>
<span class="sd">        The new state of the system as an array of int16.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute the state of the incoming links for the state</span>
    <span class="n">new_state</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prev_state</span><span class="p">,</span> <span class="n">topo_adj</span><span class="p">)</span>
    <span class="c1"># debug.print(&quot;Scaled state: {}&quot;, new_state)</span>
    <span class="c1"># Apply replacement values based on conditions</span>
    <span class="n">new_state</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">new_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">replacement_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_state</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">replacement_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_state</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="c1"># Convert the new state to int16</span>
    <span class="n">new_state</span> <span class="o">=</span> <span class="n">new_state</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_state</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.ising_bool.simulate_sync_trajectory" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">ising_bool</span><span class="o">.</span><span class="n">simulate_sync_trajectory</span><span class="p">(</span><span class="n">initial_condition</span><span class="p">,</span> <span class="n">topo_adj</span><span class="p">,</span> <span class="n">replacement_values</span><span class="p">,</span> <span class="n">max_steps</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Simulates a synchronous trajectory of a system based on the given initial condition, topology adjacency matrix, and replacement values.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>initial_condition</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The initial state of the system.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>topo_adj</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The topology adjacency matrix representing the connections between nodes in the system.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>replacement_values</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The values used to replace the states during the simulation. It is a vector of two values in the form [value_if_negative, value_if_positive].</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>max_steps</code></b>
              (<code><span title="jax.numpy.arange">arange</span></code>)
          –
          <div class="doc-md-description">
            <p>The range of steps to simulate. The simulation will run for each step in the range.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="jax.numpy.ndarray">ndarray</span></code>
          –
          <div class="doc-md-description">
            <p>A JAX array containing the states of the system at each step, with the initial condition included at the beginning. The array also includes a column for the step indices. All -1 values in the states are replaced with 0 if the replacement values are [-1, 1].</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>grins/ising_bool.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simulate_sync_trajectory</span><span class="p">(</span>
    <span class="n">initial_condition</span><span class="p">,</span>
    <span class="n">topo_adj</span><span class="p">,</span>
    <span class="n">replacement_values</span><span class="p">,</span>
    <span class="n">max_steps</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates a synchronous trajectory of a system based on the given initial condition, topology adjacency matrix, and replacement values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initial_condition : jnp.ndarray</span>
<span class="sd">        The initial state of the system.</span>
<span class="sd">    topo_adj : jnp.ndarray</span>
<span class="sd">        The topology adjacency matrix representing the connections between nodes in the system.</span>
<span class="sd">    replacement_values : jnp.ndarray</span>
<span class="sd">        The values used to replace the states during the simulation. It is a vector of two values in the form [value_if_negative, value_if_positive].</span>
<span class="sd">    max_steps : jnp.arange</span>
<span class="sd">        The range of steps to simulate. The simulation will run for each step in the range.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.ndarray</span>
<span class="sd">        A JAX array containing the states of the system at each step, with the initial condition included at the beginning. The array also includes a column for the step indices. All -1 values in the states are replaced with 0 if the replacement values are [-1, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize states array</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">step_fn</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="n">current_state</span> <span class="o">=</span> <span class="n">carry</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">sync_eval_next_state</span><span class="p">(</span>
            <span class="n">current_state</span><span class="p">,</span>
            <span class="n">topo_adj</span><span class="p">,</span>
            <span class="n">replacement_values</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">next_state</span>

    <span class="c1"># Run the simulation loop</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">states</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">step_fn</span><span class="p">,</span> <span class="n">initial_condition</span><span class="p">,</span> <span class="n">xs</span><span class="o">=</span><span class="n">max_steps</span><span class="p">)</span>
    <span class="c1"># Add the initial condition to the states at the beginning</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">initial_condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">states</span><span class="p">))</span>
    <span class="c1"># Add a column for the steps</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">states</span><span class="p">))</span>
    <span class="c1"># Make sure that states are a jax array</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="c1"># For the results where the replacement values are -1 and 1, some nodes will have -1 values, but for all purposes those should be considered as 0 values, so turning all -1 values to 0</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">states</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.ising_bool.async_eval_next_state" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">ising_bool</span><span class="o">.</span><span class="n">async_eval_next_state</span><span class="p">(</span><span class="n">prev_state</span><span class="p">,</span> <span class="n">topo_adj</span><span class="p">,</span> <span class="n">replacement_values</span><span class="p">,</span> <span class="n">update_index</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Asynchronously evaluates the next state of a node in an Ising model.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>prev_state</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The previous state vector of the system.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>topo_adj</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The adjacency matrix representing the topology of the system.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>replacement_values</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>A vector of two values used for state replacement based on conditions. The values of the vector should be [value_if_negative, value_if_positive]. The value for 0 is not included as it is assumed that the state will remain the same if the node evaluates to 0 in that step.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>update_index</code></b>
              (<code><span title="int">int</span></code>)
          –
          <div class="doc-md-description">
            <p>The index of the node to update.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="jax.numpy.ndarray">ndarray</span></code>
          –
          <div class="doc-md-description">
            <p>The new state vector after updating the specified node.</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>grins/ising_bool.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">async_eval_next_state</span><span class="p">(</span>
    <span class="n">prev_state</span><span class="p">,</span>
    <span class="n">topo_adj</span><span class="p">,</span>
    <span class="n">replacement_values</span><span class="p">,</span>  <span class="c1"># Vector of two values</span>
    <span class="n">update_index</span><span class="p">,</span>  <span class="c1"># Index of the node to update</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Asynchronously evaluates the next state of a node in an Ising model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prev_state : jnp.ndarray</span>
<span class="sd">        The previous state vector of the system.</span>
<span class="sd">    topo_adj : jnp.ndarray</span>
<span class="sd">        The adjacency matrix representing the topology of the system.</span>
<span class="sd">    replacement_values : jnp.ndarray</span>
<span class="sd">        A vector of two values used for state replacement based on conditions. The values of the vector should be [value_if_negative, value_if_positive]. The value for 0 is not included as it is assumed that the state will remain the same if the node evaluates to 0 in that step.</span>
<span class="sd">    update_index : int</span>
<span class="sd">        The index of the node to update.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.ndarray</span>
<span class="sd">        The new state vector after updating the specified node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># debug.print(&quot;Update index: {}&quot;, update_index)</span>
    <span class="c1"># debug.print(&quot;Prev state: {}&quot;, prev_state)</span>
    <span class="c1"># Compute the state update only for the selected index</span>
    <span class="n">new_value</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prev_state</span><span class="p">,</span> <span class="n">topo_adj</span><span class="p">[</span><span class="n">update_index</span><span class="p">])</span>  <span class="c1"># Only update one row</span>
    <span class="c1"># debug.print(&quot;New value0: {}&quot;, new_value)</span>
    <span class="c1"># Apply replacement values based on conditions</span>
    <span class="n">new_value</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">new_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">replacement_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">replacement_values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_state</span><span class="p">[</span><span class="n">update_index</span><span class="p">]),</span>
    <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="c1"># debug.print(&quot;New value1: {}&quot;, new_value)</span>
    <span class="c1"># Scatter the updated value into the state vector</span>
    <span class="n">new_state</span> <span class="o">=</span> <span class="n">prev_state</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">update_index</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span>
    <span class="c1"># debug.print(&quot;New state: {}&quot;, new_state)</span>
    <span class="k">return</span> <span class="n">new_state</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.ising_bool.simulate_async_trajectory" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">ising_bool</span><span class="o">.</span><span class="n">simulate_async_trajectory</span><span class="p">(</span><span class="n">initial_condition</span><span class="p">,</span> <span class="n">topo_adj</span><span class="p">,</span> <span class="n">replacement_values</span><span class="p">,</span> <span class="n">update_indices</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Simulates an asynchronous trajectory of a system given an initial condition and update indices.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>initial_condition</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The initial condition of the system.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>topo_adj</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The adjacency matrix representing the topology of the system.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>replacement_values</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>The values used to replace the states during the simulation. It is a vector of two values in the form [value_if_negative, value_if_positive].</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>update_indices</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>)
          –
          <div class="doc-md-description">
            <p>A vector of indices specifying which node to update at each step. The length of the vector should be equal to the number of steps. If not, the simulation will only run until the length of the update_indices.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="jax.numpy.ndarray">ndarray</span></code>
          –
          <div class="doc-md-description">
            <p>A JAX array containing the states of the system at each step, with the initial condition included at the beginning. The array also includes a column for the step indices. All -1 values in the states are replaced with 0 if the replacement values are [-1, 1].</p>
          </div>
        </li>
    </ul>


            <details class="quote">
              <summary>Source code in <code>grins/ising_bool.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simulate_async_trajectory</span><span class="p">(</span>
    <span class="n">initial_condition</span><span class="p">,</span>
    <span class="n">topo_adj</span><span class="p">,</span>
    <span class="n">replacement_values</span><span class="p">,</span>
    <span class="n">update_indices</span><span class="p">,</span>  <span class="c1"># Vector of indices specifying which node to update at each step</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates an asynchronous trajectory of a system given an initial condition and update indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initial_condition : jnp.ndarray</span>
<span class="sd">        The initial condition of the system.</span>
<span class="sd">    topo_adj : jnp.ndarray</span>
<span class="sd">        The adjacency matrix representing the topology of the system.</span>
<span class="sd">    replacement_values : jnp.ndarray</span>
<span class="sd">        The values used to replace the states during the simulation. It is a vector of two values in the form [value_if_negative, value_if_positive].</span>
<span class="sd">    update_indices : jnp.ndarray</span>
<span class="sd">        A vector of indices specifying which node to update at each step. The length of the vector should be equal to the number of steps. If not, the simulation will only run until the length of the update_indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jnp.ndarray</span>
<span class="sd">        A JAX array containing the states of the system at each step, with the initial condition included at the beginning. The array also includes a column for the step indices. All -1 values in the states are replaced with 0 if the replacement values are [-1, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">step_fn</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">update_index</span><span class="p">):</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">async_eval_next_state</span><span class="p">(</span>
            <span class="n">carry</span><span class="p">,</span>
            <span class="n">topo_adj</span><span class="p">,</span>
            <span class="n">replacement_values</span><span class="p">,</span>
            <span class="n">update_index</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">next_state</span>

    <span class="c1"># Run the simulation loop, passing update_indices as xs</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">states</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">step_fn</span><span class="p">,</span> <span class="n">initial_condition</span><span class="p">,</span> <span class="n">xs</span><span class="o">=</span><span class="n">update_indices</span><span class="p">)</span>
    <span class="c1"># Add the initial condition to the states at the beginning</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">initial_condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">states</span><span class="p">))</span>
    <span class="c1"># Add a column for the steps</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">states</span><span class="p">))</span>
    <span class="c1"># Make sure that states are the right dtype</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="c1"># For the results where the replacement values are -1 and 1, some nodes will have -1 values, but for all purposes those should be considered as 0 values, so turning all -1 values to 0</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">states</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">states</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.ising_bool.run_simulations" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">ising_bool</span><span class="o">.</span><span class="n">run_simulations</span><span class="p">(</span><span class="n">topo_file</span><span class="p">,</span> <span class="n">num_initial_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inital_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replacement_values</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;sync&#39;</span><span class="p">,</span> <span class="n">packbits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s1">&#39;IsingSimulResults&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Run synchronous or asynchronous simulations for a given topology.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>topo_file</code></b>
              (<code><span title="str">str</span></code>)
          –
          <div class="doc-md-description">
            <p>The path to the topology file.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>num_initial_conditions</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>The number of initial conditions to sample. If not provided, the default is 2**10.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>inital_conditions</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>The initial conditions matrix with the individual initial conditions as rows of the matrix. If provided, num_initial_conditions is ignored.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>max_steps</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>The maximum number of steps to simulate. If not provided, it is calculated to be 10 times the number of nodes.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>batch_size</code></b>
              (<code><span title="int">int</span></code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>The number of samples per batch. If not provided, the default is 2**10.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>replacement_values</code></b>
              (<code><span title="jax.numpy.ndarray">ndarray</span></code>, default:
                  <code><span title="jax.numpy.array">array</span>([0, 1])</code>
)
          –
          <div class="doc-md-description">
            <p>The values used for replacement in the simulation. The default is [0, 1].</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>mode</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;sync&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The simulation mode, either "sync" or "async". The default is "sync".</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>packbits</code></b>
              (<code><span title="bool">bool</span></code>, default:
                  <code>False</code>
)
          –
          <div class="doc-md-description">
            <p>Whether to pack the 0/1 states into bits to reduce memory usage. The default is False.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>save_dir</code></b>
              (<code><span title="str">str</span></code>, default:
                  <code>&#39;IsingSimulResults&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The directory to save the simulation results. The default is "IsingSimulResults".</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>None</code>
          –
          <div class="doc-md-description">
            <p>The simulation results are saved to a parquet file in save_dir within a subdirectory named after the topology file.</p>
          </div>
        </li>
    </ul>


<details class="example" open>
  <summary>Example</summary>
  <p>Run the synchronous simulation for a topology file:</p>
<blockquote>
<blockquote>
<blockquote>
<p>run_simulations(
...     topo_file="TOPOS/ER_1000_0.1.topo",
...     num_initial_conditions=2<strong>10,
...     max_steps=100,
...     batch_size=2</strong>10,
...     replacement_values=jnp.array([0, 1]),
...     mode="sync",
...     packbits=True,
...     save_dir="IsingSimulResults",
... )</p>
</blockquote>
</blockquote>
</blockquote>
<p>This will save the simulation results to a parquet file in the directory "IsingSimulResults/ER_1000_0.1/ER_1000_0.1_sync_results.parquet".</p>
<p>Similary, the asynchronous simulation can be run by setting mode="async".</p>
<p>If the initial conditions matrix is provided, the num_initial_conditions parameter is ignored. In this case, the initial_conditions matrix should have the individual initial conditions as rows.
If only specfic inital conditions are to be used, the initial conditions matrix can be provided with the individual initial conditions as rows of the matrix. This provides control over simulating specific pre-defined initial conditions.</p>
<blockquote>
<blockquote>
<blockquote>
<p>initial_conditions = jnp.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 0, 1, 1]])
run_simulations(
...     topo_file="TOPOS/ER_1000_0.1.topo",
...     initial_conditions=initial_conditions,
...     max_steps=100,
...     batch_size=2**10,
...     replacement_values=jnp.array([0, 1]),
...     mode="sync",
...     packbits=True,
...     save_dir="IsingSimulResults",
... )</p>
</blockquote>
</blockquote>
</blockquote>
<p>For cases where the replacement values are not [0, 1], the replacement values should be provided as a jax array of length 2 with the first value less than the second.</p>
<blockquote>
<blockquote>
<blockquote>
<p>replacement_values = jnp.array([-1, 1]) # Replacement values are -1 for negetive and 1 for positive
run_simulations(
...     topo_file="TOPOS/ER_1000_0.1.topo",
...     num_initial_conditions=2<strong>10,
...     max_steps=100,
...     batch_size=2</strong>10,
...     replacement_values=replacement_values,
...     mode="sync",
...     packbits=True,
...     save_dir="IsingSimulResults",
... )</p>
</blockquote>
</blockquote>
</blockquote>
<p>The results for [-1, 1] replacment values will also be converted to 0 for all the -1 or 0 values in the states and 1s will remain as 1s when saving to the file. This is important as otherwise the packbits  would not work.</p>
<p>The packbits function used is jnp.packbits which packs the 0/1 states into bits to reduce memory usage. This is useful when the number of nodes is large and the number of steps is also large. The memory usase can be reduced by a factor of 8 by packing the states into bits. If packbits is not set to True, the states are saved as is.</p>
<blockquote>
<blockquote>
<blockquote>
<p>run_simulations(
...     topo_file="TOPOS/ER_1000_0.1.topo",
...     num_initial_conditions=2<strong>10,
...     max_steps=100,
...     batch_size=2</strong>10,
...     replacement_values=jnp.array([0, 1]),
...     mode="sync",
...     packbits=False,
...     save_dir="IsingSimulResults",
... )</p>
</blockquote>
</blockquote>
</blockquote>
<p>The final dataframe which is written to the parquet file has the following columns for the packbits=False case:
- Step: The step number for the simulation.
- Node names: The names of the nodes in the network.
If the packbits=True, the final dataframe has the following columns:
- Step: The step number for the simulation.
- Byte_i: The ith byte of the packed states for the simulation.
The Byte_i columns are created based on the number of nodes in the network. For example, if there are 100 nodes, there will be 13 columns for the packed states. They can be unpacked using jnp.unpackbits to get the unpacked state values.
The order of the nodes for the Byte_i columns is the same as the order of the nodes in the network after parsing the topology file using the parse_topo_to_matrix function. The order of the nodes is saved in a text file in the simulation directory for easy reference. The naming convention for the text file is toponame_node_names_order.csv.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>grins/ising_bool.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_simulations</span><span class="p">(</span>
    <span class="n">topo_file</span><span class="p">,</span>
    <span class="n">num_initial_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">inital_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">replacement_values</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;sync&quot;</span><span class="p">,</span>
    <span class="n">packbits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">save_dir</span><span class="o">=</span><span class="s2">&quot;IsingSimulResults&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run synchronous or asynchronous simulations for a given topology.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topo_file : str</span>
<span class="sd">        The path to the topology file.</span>
<span class="sd">    num_initial_conditions : int, optional</span>
<span class="sd">        The number of initial conditions to sample. If not provided, the default is 2**10.</span>
<span class="sd">    inital_conditions : jax.numpy.ndarray, optional</span>
<span class="sd">        The initial conditions matrix with the individual initial conditions as rows of the matrix. If provided, num_initial_conditions is ignored.</span>
<span class="sd">    max_steps : int, optional</span>
<span class="sd">        The maximum number of steps to simulate. If not provided, it is calculated to be 10 times the number of nodes.</span>
<span class="sd">    batch_size : int, optional</span>
<span class="sd">        The number of samples per batch. If not provided, the default is 2**10.</span>
<span class="sd">    replacement_values : jax.numpy.ndarray, optional</span>
<span class="sd">        The values used for replacement in the simulation. The default is [0, 1].</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        The simulation mode, either &quot;sync&quot; or &quot;async&quot;. The default is &quot;sync&quot;.</span>
<span class="sd">    packbits : bool, optional</span>
<span class="sd">        Whether to pack the 0/1 states into bits to reduce memory usage. The default is False.</span>
<span class="sd">    save_dir : str, optional</span>
<span class="sd">        The directory to save the simulation results. The default is &quot;IsingSimulResults&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The simulation results are saved to a parquet file in save_dir within a subdirectory named after the topology file.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Run the synchronous simulation for a topology file:</span>

<span class="sd">    &gt;&gt;&gt; run_simulations(</span>
<span class="sd">    ...     topo_file=&quot;TOPOS/ER_1000_0.1.topo&quot;,</span>
<span class="sd">    ...     num_initial_conditions=2**10,</span>
<span class="sd">    ...     max_steps=100,</span>
<span class="sd">    ...     batch_size=2**10,</span>
<span class="sd">    ...     replacement_values=jnp.array([0, 1]),</span>
<span class="sd">    ...     mode=&quot;sync&quot;,</span>
<span class="sd">    ...     packbits=True,</span>
<span class="sd">    ...     save_dir=&quot;IsingSimulResults&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    This will save the simulation results to a parquet file in the directory &quot;IsingSimulResults/ER_1000_0.1/ER_1000_0.1_sync_results.parquet&quot;.</span>

<span class="sd">    Similary, the asynchronous simulation can be run by setting mode=&quot;async&quot;.</span>

<span class="sd">    If the initial conditions matrix is provided, the num_initial_conditions parameter is ignored. In this case, the initial_conditions matrix should have the individual initial conditions as rows.</span>
<span class="sd">    If only specfic inital conditions are to be used, the initial conditions matrix can be provided with the individual initial conditions as rows of the matrix. This provides control over simulating specific pre-defined initial conditions.</span>

<span class="sd">    &gt;&gt;&gt; initial_conditions = jnp.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 0, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; run_simulations(</span>
<span class="sd">    ...     topo_file=&quot;TOPOS/ER_1000_0.1.topo&quot;,</span>
<span class="sd">    ...     initial_conditions=initial_conditions,</span>
<span class="sd">    ...     max_steps=100,</span>
<span class="sd">    ...     batch_size=2**10,</span>
<span class="sd">    ...     replacement_values=jnp.array([0, 1]),</span>
<span class="sd">    ...     mode=&quot;sync&quot;,</span>
<span class="sd">    ...     packbits=True,</span>
<span class="sd">    ...     save_dir=&quot;IsingSimulResults&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    For cases where the replacement values are not [0, 1], the replacement values should be provided as a jax array of length 2 with the first value less than the second.</span>

<span class="sd">    &gt;&gt;&gt; replacement_values = jnp.array([-1, 1]) # Replacement values are -1 for negetive and 1 for positive</span>
<span class="sd">    &gt;&gt;&gt; run_simulations(</span>
<span class="sd">    ...     topo_file=&quot;TOPOS/ER_1000_0.1.topo&quot;,</span>
<span class="sd">    ...     num_initial_conditions=2**10,</span>
<span class="sd">    ...     max_steps=100,</span>
<span class="sd">    ...     batch_size=2**10,</span>
<span class="sd">    ...     replacement_values=replacement_values,</span>
<span class="sd">    ...     mode=&quot;sync&quot;,</span>
<span class="sd">    ...     packbits=True,</span>
<span class="sd">    ...     save_dir=&quot;IsingSimulResults&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    The results for [-1, 1] replacment values will also be converted to 0 for all the -1 or 0 values in the states and 1s will remain as 1s when saving to the file. This is important as otherwise the packbits  would not work.</span>

<span class="sd">    The packbits function used is jnp.packbits which packs the 0/1 states into bits to reduce memory usage. This is useful when the number of nodes is large and the number of steps is also large. The memory usase can be reduced by a factor of 8 by packing the states into bits. If packbits is not set to True, the states are saved as is.</span>

<span class="sd">    &gt;&gt;&gt; run_simulations(</span>
<span class="sd">    ...     topo_file=&quot;TOPOS/ER_1000_0.1.topo&quot;,</span>
<span class="sd">    ...     num_initial_conditions=2**10,</span>
<span class="sd">    ...     max_steps=100,</span>
<span class="sd">    ...     batch_size=2**10,</span>
<span class="sd">    ...     replacement_values=jnp.array([0, 1]),</span>
<span class="sd">    ...     mode=&quot;sync&quot;,</span>
<span class="sd">    ...     packbits=False,</span>
<span class="sd">    ...     save_dir=&quot;IsingSimulResults&quot;,</span>
<span class="sd">    ... )</span>

<span class="sd">    The final dataframe which is written to the parquet file has the following columns for the packbits=False case:</span>
<span class="sd">    - Step: The step number for the simulation.</span>
<span class="sd">    - Node names: The names of the nodes in the network.</span>
<span class="sd">    If the packbits=True, the final dataframe has the following columns:</span>
<span class="sd">    - Step: The step number for the simulation.</span>
<span class="sd">    - Byte_i: The ith byte of the packed states for the simulation.</span>
<span class="sd">    The Byte_i columns are created based on the number of nodes in the network. For example, if there are 100 nodes, there will be 13 columns for the packed states. They can be unpacked using jnp.unpackbits to get the unpacked state values.</span>
<span class="sd">    The order of the nodes for the Byte_i columns is the same as the order of the nodes in the network after parsing the topology file using the parse_topo_to_matrix function. The order of the nodes is saved in a text file in the simulation directory for easy reference. The naming convention for the text file is toponame_node_names_order.csv.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create the save directory if it does not exist</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Create a subdirectory for the topology file</span>
    <span class="n">topo_name</span> <span class="o">=</span> <span class="n">topo_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sim_dir</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">sim_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Get the adjacency matrix and node names</span>
    <span class="n">topo_adj</span><span class="p">,</span> <span class="n">node_names</span> <span class="o">=</span> <span class="n">parse_topo_to_matrix</span><span class="p">(</span><span class="n">topo_file</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> simulations for the network: </span><span class="si">{</span><span class="n">topo_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Default batch size if not specified</span>
    <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">10</span>
    <span class="c1"># Default max steps if not specified</span>
    <span class="k">if</span> <span class="n">max_steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Determine max steps based on number of nodes</span>
        <span class="n">max_steps</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>
    <span class="c1"># Check if Inital conditions matrix is provided</span>
    <span class="k">if</span> <span class="n">inital_conditions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Default number of inital conditions if not specified</span>
        <span class="k">if</span> <span class="n">num_initial_conditions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_initial_conditions</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">10</span>
        <span class="c1"># Generate random initial conditions</span>
        <span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">generate_intial_conditions</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">),</span> <span class="n">num_initial_conditions</span>
        <span class="p">)</span>
    <span class="c1"># Check if the replacement values provided have length 2 and that the first value is less than the second</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">replacement_values</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">replacement_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">replacement_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Replacement values must be a jax array of length 2 with the first value less than the second.&quot;</span>
        <span class="p">)</span>
    <span class="c1"># Initialize an empty numpy array to store the results</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">packbits</span><span class="p">:</span>
        <span class="n">results_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="c1"># Create the column names for the dataframe</span>
        <span class="n">df_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Step&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">node_names</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">results_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span>
        <span class="p">)</span>
        <span class="c1"># Create the column names for the dataframe</span>
        <span class="n">df_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Step&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;Byte_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)))</span>
        <span class="p">]</span>
        <span class="c1"># Create a text file with the node names seperated by a comma for easy reference</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sim_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_node_names_order.csv&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">node_names</span><span class="p">))</span>
    <span class="c1"># Start the simulation timer</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># Run synchronous or asynchronous simulations</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;sync&quot;</span><span class="p">:</span>
        <span class="c1"># Run synchronous simulations in batches</span>
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_initial_conditions</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
            <span class="n">batch_initial_conditions</span> <span class="o">=</span> <span class="n">initial_conditions</span><span class="p">[</span><span class="n">batch</span> <span class="p">:</span> <span class="n">batch</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>
            <span class="n">batch_results</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">simulate_sync_trajectory</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span>
                    <span class="n">topo_adj</span><span class="p">,</span>
                    <span class="n">replacement_values</span><span class="p">,</span>
                    <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_steps</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="n">in_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)(</span><span class="n">batch_initial_conditions</span><span class="p">)</span>
            <span class="c1"># Stack the batch results into a single array</span>
            <span class="n">batch_results</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">batch_results</span><span class="p">)</span>
            <span class="c1"># If packbits is True, pack the 0/1 states into bits to reduce memory usage</span>
            <span class="k">if</span> <span class="n">packbits</span><span class="p">:</span>
                <span class="n">batch_results</span> <span class="o">=</span> <span class="n">packbit_states</span><span class="p">(</span><span class="n">batch_results</span><span class="p">)</span>
            <span class="c1"># Append the batch results to the main results array</span>
            <span class="n">results_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">results_array</span><span class="p">,</span> <span class="n">batch_results</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;async&quot;</span><span class="p">:</span>
        <span class="c1"># Generate random update indices for asynchronous updates</span>
        <span class="n">update_indices_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">),</span> <span class="p">(</span><span class="n">max_steps</span><span class="p">,</span> <span class="n">num_initial_conditions</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">update_indices_matrix</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">update_indices_matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
        <span class="c1"># Run asynchronous simulations in batches</span>
        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_initial_conditions</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
            <span class="n">batch_initial_conditions</span> <span class="o">=</span> <span class="n">initial_conditions</span><span class="p">[</span><span class="n">batch</span> <span class="p">:</span> <span class="n">batch</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>
            <span class="n">batch_update_indices</span> <span class="o">=</span> <span class="n">update_indices_matrix</span><span class="p">[:,</span> <span class="n">batch</span> <span class="p">:</span> <span class="n">batch</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>
            <span class="n">batch_states</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">simulate_async_trajectory</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span>
                    <span class="n">topo_adj</span><span class="p">,</span>
                    <span class="n">replacement_values</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)(</span><span class="n">batch_initial_conditions</span><span class="p">,</span> <span class="n">batch_update_indices</span><span class="p">)</span>
            <span class="c1"># Stack the batch results into a single array</span>
            <span class="n">batch_states</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">batch_states</span><span class="p">)</span>
            <span class="c1"># If packbits is True, pack the 0/1 states into bits to reduce memory usage</span>
            <span class="k">if</span> <span class="n">packbits</span><span class="p">:</span>
                <span class="n">batch_states</span> <span class="o">=</span> <span class="n">packbit_states</span><span class="p">(</span><span class="n">batch_states</span><span class="p">)</span>
            <span class="c1"># Append the batch results to the main results array</span>
            <span class="n">results_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">results_array</span><span class="p">,</span> <span class="n">batch_states</span><span class="p">))</span>

    <span class="c1"># Create a dataframe from the results array</span>
    <span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results_array</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">df_cols</span><span class="p">)</span>
    <span class="c1"># Saving the results to a parquet file</span>
    <span class="n">results_df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sim_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">_ising_results.parquet&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="c1"># End the simulation timer</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulation time for </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> mode: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2024 CSB Lab, BE Dept, IISc
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.sections", "toc.integrate", "header.autohide"], "search": "../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>