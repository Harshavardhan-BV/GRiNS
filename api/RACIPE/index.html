
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="GRiNS: Gene Regulatory Interaction Network Simulator Documentation">
      
      
      
        <link rel="canonical" href="https://MoltenEcdysone09.github.io/GRiNS/api/RACIPE/">
      
      
        <link rel="prev" href="../../usage/RACIPE_Tutorial/">
      
      
        <link rel="next" href="../IsingBoolean/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.7">
    
    
      
        <title>RACIPE - GRiNS</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#racipe-formalism" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="GRiNS" class="md-header__button md-logo" aria-label="GRiNS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            GRiNS
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              RACIPE
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/MoltenEcdysone09/GRiNS" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    MoltenEcdysone09/GRiNS
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="GRiNS" class="md-nav__button md-logo" aria-label="GRiNS" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    GRiNS
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/MoltenEcdysone09/GRiNS" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    MoltenEcdysone09/GRiNS
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Usage
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Usage
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/racipe/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RACIPE
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/IsingBoolean.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    None
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/RACIPE_Tutorial/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RACIPE Simulations Tutorial
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
      
        
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    API
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            API
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    RACIPE
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    RACIPE
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#grn-parsing-and-ode-generation-functions" class="md-nav__link">
    <span class="md-ellipsis">
      GRN Parsing and ODE Generation Functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.reg_funcs.psH" class="md-nav__link">
    <span class="md-ellipsis">
      psH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.reg_funcs.nsH" class="md-nav__link">
    <span class="md-ellipsis">
      nsH
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.gen_diffrax_ode.gen_diffrax_odesys" class="md-nav__link">
    <span class="md-ellipsis">
      gen_diffrax_odesys
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parameters-and-intial-conditions-generation-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters and Intial Conditions Generation Functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.gen_params.parse_topos" class="md-nav__link">
    <span class="md-ellipsis">
      parse_topos
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.gen_params.gen_param_names" class="md-nav__link">
    <span class="md-ellipsis">
      gen_param_names
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.gen_params.sample_distribution" class="md-nav__link">
    <span class="md-ellipsis">
      sample_distribution
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.gen_params.gen_param_range_df" class="md-nav__link">
    <span class="md-ellipsis">
      gen_param_range_df
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.gen_params.gen_param_df" class="md-nav__link">
    <span class="md-ellipsis">
      gen_param_df
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.gen_params.gen_init_cond" class="md-nav__link">
    <span class="md-ellipsis">
      gen_init_cond
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#simulation-related-functions" class="md-nav__link">
    <span class="md-ellipsis">
      Simulation Related Functions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.racipe_run.gen_sim_dirstruct" class="md-nav__link">
    <span class="md-ellipsis">
      gen_sim_dirstruct
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.racipe_run.gen_topo_param_files" class="md-nav__link">
    <span class="md-ellipsis">
      gen_topo_param_files
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.racipe_run.load_odeterm" class="md-nav__link">
    <span class="md-ellipsis">
      load_odeterm
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.racipe_run.topo_simulate" class="md-nav__link">
    <span class="md-ellipsis">
      topo_simulate
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.racipe_run.gk_normalise_solutions" class="md-nav__link">
    <span class="md-ellipsis">
      gk_normalise_solutions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.racipe_run.discretise_solutions" class="md-nav__link">
    <span class="md-ellipsis">
      discretise_solutions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#grins.racipe_run.run_all_replicates" class="md-nav__link">
    <span class="md-ellipsis">
      run_all_replicates
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../IsingBoolean/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Ising Boolean
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="racipe-formalism">RACIPE Formalism</h1>
<p>Functions related to RACIPE simulation.</p>
<h2 id="grn-parsing-and-ode-generation-functions">GRN Parsing and ODE Generation Functions</h2>
<hr />


<div class="doc doc-object doc-function">


<h2 id="grins.reg_funcs.psH" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">reg_funcs</span><span class="o">.</span><span class="n">psH</span><span class="p">(</span><span class="n">nod</span><span class="p">,</span> <span class="n">fld</span><span class="p">,</span> <span class="n">thr</span><span class="p">,</span> <span class="n">hill</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Positive Shifted Hill function.</p>
<p>Parameters:
    nod (float): The node expression value.
    fld (float): The fold change.
    thr (float): The half-maximal threshold value.
    hill (float): The hill coefficient.</p>
<p>Returns:
    (float): The value of the Positive Shifted Hill function.</p>


            <details class="quote">
              <summary>Source code in <code>grins/reg_funcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">psH</span><span class="p">(</span><span class="n">nod</span><span class="p">,</span> <span class="n">fld</span><span class="p">,</span> <span class="n">thr</span><span class="p">,</span> <span class="n">hill</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Positive Shifted Hill function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        nod (float): The node expression value.</span>
<span class="sd">        fld (float): The fold change.</span>
<span class="sd">        thr (float): The half-maximal threshold value.</span>
<span class="sd">        hill (float): The hill coefficient.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (float): The value of the Positive Shifted Hill function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">fld</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fld</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">nod</span> <span class="o">/</span> <span class="n">thr</span><span class="p">)</span> <span class="o">**</span> <span class="n">hill</span><span class="p">)))</span> <span class="o">/</span> <span class="n">fld</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.reg_funcs.nsH" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">reg_funcs</span><span class="o">.</span><span class="n">nsH</span><span class="p">(</span><span class="n">nod</span><span class="p">,</span> <span class="n">fld</span><span class="p">,</span> <span class="n">thr</span><span class="p">,</span> <span class="n">hill</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Negative Shifted Hill function.</p>
<p>Parameters:
    nod (float): The node expression value.
    fld (float): The fold change.
    thr (float): The half-maximal threshold value.
    hill (float): The hill coefficient.</p>
<p>Returns:
    (float): The value of the Negative Shifted Hill function.</p>


            <details class="quote">
              <summary>Source code in <code>grins/reg_funcs.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nsH</span><span class="p">(</span><span class="n">nod</span><span class="p">,</span> <span class="n">fld</span><span class="p">,</span> <span class="n">thr</span><span class="p">,</span> <span class="n">hill</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Negative Shifted Hill function.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        nod (float): The node expression value.</span>
<span class="sd">        fld (float): The fold change.</span>
<span class="sd">        thr (float): The half-maximal threshold value.</span>
<span class="sd">        hill (float): The hill coefficient.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (float): The value of the Negative Shifted Hill function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fld</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fld</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">nod</span> <span class="o">/</span> <span class="n">thr</span><span class="p">)</span><span class="o">**</span> <span class="n">hill</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.gen_diffrax_ode.gen_diffrax_odesys" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">gen_diffrax_ode</span><span class="o">.</span><span class="n">gen_diffrax_odesys</span><span class="p">(</span><span class="n">topo_df</span><span class="p">,</span> <span class="n">topo_name</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generate the ODE system code for diffrax based on the given topology dataframe.</p>
<p>Args:
    topo_df (pandas.DataFrame): The topology dataframe containing the edges information.
    topo_name (str): The name of the topology.
    save_dir (str, optional): The directory to save the generated code. Defaults to ".".</p>
<p>Returns:
    None:  Saves the generated file in the driectory specified by save_dir.</p>


            <details class="quote">
              <summary>Source code in <code>grins/gen_diffrax_ode.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_diffrax_odesys</span><span class="p">(</span><span class="n">topo_df</span><span class="p">,</span> <span class="n">topo_name</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the ODE system code for diffrax based on the given topology dataframe.</span>

<span class="sd">    Args:</span>
<span class="sd">        topo_df (pandas.DataFrame): The topology dataframe containing the edges information.</span>
<span class="sd">        topo_name (str): The name of the topology.</span>
<span class="sd">        save_dir (str, optional): The directory to save the generated code. Defaults to &quot;.&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None:  Saves the generated file in the driectory specified by save_dir.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the list of parameters, target nodes and source nodes</span>
    <span class="n">param_names_list</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">,</span> <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">gen_param_names</span><span class="p">(</span><span class="n">topo_df</span><span class="p">)</span>
    <span class="c1"># List of unique nodes</span>
    <span class="n">unique_nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">target_nodes</span> <span class="o">+</span> <span class="n">source_nodes</span><span class="p">))</span>
    <span class="c1"># Inititalise a list to store the ODE strings</span>
    <span class="n">ode_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;import grins.reg_funcs as regfn</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;def odesys(t,y,args):&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">) = y&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">param_names_list</span><span class="p">)</span><span class="si">}</span><span class="s2">) = args&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="c1"># Loop through the target nodes</span>
    <span class="k">for</span> <span class="n">ni</span><span class="p">,</span> <span class="n">nod</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">):</span>
        <span class="c1"># Get the edges where n is the target node</span>
        <span class="n">target_edges</span> <span class="o">=</span> <span class="n">topo_df</span><span class="p">[</span><span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">nod</span><span class="p">]</span>
        <span class="c1"># The diffrax ODE for each node is d_&lt;nod&gt; = &lt;ODE&gt;</span>
        <span class="n">ode_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;d_</span><span class="si">{</span><span class="n">nod</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">gen_node_ode</span><span class="p">(</span><span class="n">target_edges</span><span class="p">,</span><span class="w"> </span><span class="n">nod</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Append the d_y line</span>
    <span class="n">ode_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">d_y = (</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;d_</span><span class="si">{</span><span class="n">nod</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">nod</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">unique_nodes</span><span class="p">])</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="c1"># Append the end line</span>
    <span class="n">ode_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">return d_y</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Write the lines to a file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">.py&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ode_list</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><hr />
<h2 id="parameters-and-intial-conditions-generation-functions">Parameters and Intial Conditions Generation Functions</h2>
<hr />


<div class="doc doc-object doc-function">


<h2 id="grins.gen_params.parse_topos" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">gen_params</span><span class="o">.</span><span class="n">parse_topos</span><span class="p">(</span><span class="n">topofile</span><span class="p">,</span> <span class="n">save_cleaned</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Parse and cleans the given topofile and return the dataframe. It is expeced that the topo files is a tab-separated file with three columns: Source, Target, and Type. White spaces can also be used to separate the columns.</p>
<p>For nodes that are not alphanumeric, the function will replace the non-alphanumeric characters with an underscore and prepend "Node_" if the node name does not start with an alphabet. The cleaned topology file will be saved if the save_cleaned flag is set to True.</p>
<p>Parameters:
    topofile (str): The path to the topofile.
    save_cleaned (bool, optional): If True, save the cleaned topology file. Defaults to False.</p>
<p>Returns:
    topo_df (pandas.DataFrame): The parsed dataframe.</p>


            <details class="quote">
              <summary>Source code in <code>grins/gen_params.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">parse_topos</span><span class="p">(</span><span class="n">topofile</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">save_cleaned</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse and cleans the given topofile and return the dataframe. It is expeced that the topo files is a tab-separated file with three columns: Source, Target, and Type. White spaces can also be used to separate the columns.</span>

<span class="sd">    For nodes that are not alphanumeric, the function will replace the non-alphanumeric characters with an underscore and prepend &quot;Node_&quot; if the node name does not start with an alphabet. The cleaned topology file will be saved if the save_cleaned flag is set to True.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        topofile (str): The path to the topofile.</span>
<span class="sd">        save_cleaned (bool, optional): If True, save the cleaned topology file. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        topo_df (pandas.DataFrame): The parsed dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">topo_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">topofile</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">topo_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The topology file should have three columns: Source, Target, and Type.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="n">topo_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Source&quot;</span><span class="p">,</span> <span class="s2">&quot;Target&quot;</span><span class="p">,</span> <span class="s2">&quot;Type&quot;</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The topology file should have the columns: Source, Target, and Type.&quot;</span>
        <span class="p">)</span>
    <span class="n">topo_df</span> <span class="o">=</span> <span class="n">topo_df</span><span class="p">[[</span><span class="s2">&quot;Source&quot;</span><span class="p">,</span> <span class="s2">&quot;Target&quot;</span><span class="p">,</span> <span class="s2">&quot;Type&quot;</span><span class="p">]]</span>
    <span class="c1"># Clean up node names: replace non-alphanumerics and prepend &quot;Node_&quot; if needed.</span>
    <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Source&quot;</span><span class="p">]</span>
        <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Node_</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="k">else</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span>
        <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Node_</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="k">else</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Check the topo file: </span><span class="si">{</span><span class="n">topofile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save_cleaned</span><span class="p">:</span>
        <span class="n">topo_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="n">topofile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.topo&quot;</span><span class="p">,</span> <span class="s2">&quot;_cleaned.topo&quot;</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">topo_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.gen_params.gen_param_names" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">gen_params</span><span class="o">.</span><span class="n">gen_param_names</span><span class="p">(</span><span class="n">topo_df</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generate parameter names based on the given topology dataframe.</p>
<p>Parameters:
    topo_df (pandas.DataFrame): The topology dataframe containing the information about the nodes and edges.</p>
<p>Returns:
    tuple: A tuple containing the parameter names, unique target node names, and unique source node names.</p>


            <details class="quote">
              <summary>Source code in <code>grins/gen_params.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_param_names</span><span class="p">(</span><span class="n">topo_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate parameter names based on the given topology dataframe.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        topo_df (pandas.DataFrame): The topology dataframe containing the information about the nodes and edges.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the parameter names, unique target node names, and unique source node names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
    <span class="n">source_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
    <span class="n">unique_nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">source_nodes</span> <span class="o">+</span> <span class="n">target_nodes</span><span class="p">))</span>
    <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Prod_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">unique_nodes</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;Deg_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">unique_nodes</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">tn</span> <span class="ow">in</span> <span class="n">unique_nodes</span><span class="p">:</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="n">topo_df</span><span class="p">[</span><span class="n">topo_df</span><span class="p">[</span><span class="s2">&quot;Target&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tn</span><span class="p">][</span><span class="s2">&quot;Source&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;Fld&quot;</span><span class="p">,</span> <span class="s2">&quot;Thr&quot;</span><span class="p">,</span> <span class="s2">&quot;Hill&quot;</span><span class="p">]):</span>
            <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">sn</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">tn</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="s2">&quot;Fld&quot;</span> <span class="k">else</span> <span class="n">_get_regtype</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">topo_df</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">,</span> <span class="n">source_nodes</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.gen_params.sample_distribution" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">gen_params</span><span class="o">.</span><span class="n">sample_distribution</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">std_dev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimise</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generates a sample distribution based on the specified method.</p>
<p>Parameters:
    method (str): The sampling method to use. Options are "Sobol", "LHS", "Uniform", "LogUniform", "Normal", "LogNormal".
    dimension (int): The number of dimensions for the sample points.
    num_points (int): The number of sample points to generate.
    std_dev (Optional[float]): The standard deviation for the "Normal" and "LogNormal" distributions. Defaults to 1.0 if not provided.
    optimise (bool): Whether to optimise the sampling process. Applicable for "Sobol" and "LHS" methods.</p>
<p>Returns:
    np.ndarray: An array of sample points generated according to the specified method.</p>
<p>Raises:
    ValueError: If an unknown sampling method is specified.</p>


            <details class="quote">
              <summary>Source code in <code>grins/gen_params.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sample_distribution</span><span class="p">(</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">std_dev</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">optimise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a sample distribution based on the specified method.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        method (str): The sampling method to use. Options are &quot;Sobol&quot;, &quot;LHS&quot;, &quot;Uniform&quot;, &quot;LogUniform&quot;, &quot;Normal&quot;, &quot;LogNormal&quot;.</span>
<span class="sd">        dimension (int): The number of dimensions for the sample points.</span>
<span class="sd">        num_points (int): The number of sample points to generate.</span>
<span class="sd">        std_dev (Optional[float]): The standard deviation for the &quot;Normal&quot; and &quot;LogNormal&quot; distributions. Defaults to 1.0 if not provided.</span>
<span class="sd">        optimise (bool): Whether to optimise the sampling process. Applicable for &quot;Sobol&quot; and &quot;LHS&quot; methods.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: An array of sample points generated according to the specified method.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If an unknown sampling method is specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Sobol&quot;</span><span class="p">:</span>
        <span class="n">dist_arr</span> <span class="o">=</span> <span class="n">_gen_sobol_seq</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">optimise</span><span class="p">)</span>
        <span class="c1"># return _gen_sobol_seq(dimension, num_points, optimise)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;LHS&quot;</span><span class="p">:</span>
        <span class="n">dist_arr</span> <span class="o">=</span> <span class="n">_gen_latin_hypercube</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">optimise</span><span class="p">)</span>
        <span class="c1"># return _gen_latin_hypercube(dimension, num_points, optimise)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Uniform&quot;</span><span class="p">:</span>
        <span class="n">dist_arr</span> <span class="o">=</span> <span class="n">_gen_uniform_seq</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
        <span class="c1"># return _gen_uniform_seq(dimension, num_points)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;LogUniform&quot;</span><span class="p">:</span>
        <span class="n">dist_arr</span> <span class="o">=</span> <span class="n">_gen_loguniform_seq</span><span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
        <span class="c1"># return _gen_loguniform_seq(dimension, num_points)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Normal&quot;</span><span class="p">:</span>
        <span class="n">dist_arr</span> <span class="o">=</span> <span class="n">_gen_normal</span><span class="p">(</span>
            <span class="n">dimension</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">std_dev</span> <span class="k">if</span> <span class="n">std_dev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="p">)</span>
        <span class="c1"># return _gen_normal(</span>
        <span class="c1">#     dimension, num_points, std_dev if std_dev is not None else 1.0</span>
        <span class="c1"># )</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;LogNormal&quot;</span><span class="p">:</span>
        <span class="n">dist_arr</span> <span class="o">=</span> <span class="n">_gen_lognormal</span><span class="p">(</span>
            <span class="n">dimension</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">std_dev</span> <span class="k">if</span> <span class="n">std_dev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="p">)</span>
        <span class="c1"># return _gen_lognormal(</span>
        <span class="c1">#     dimension, num_points, std_dev if std_dev is not None else 1.0</span>
        <span class="c1"># )</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown sampling method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Shuffle the array to avoid the correlation between the parameters</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">dist_arr</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dist_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.gen_params.gen_param_range_df" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">gen_params</span><span class="o">.</span><span class="n">gen_param_range_df</span><span class="p">(</span><span class="n">topo_df</span><span class="p">,</span> <span class="n">num_params</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sampling_method</span><span class="o">=</span><span class="s1">&#39;Sobol&#39;</span><span class="p">,</span> <span class="n">thr_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generate a parameter range DataFrame from the topology DataFrame.</p>


<details class="parameters:" open>
  <summary>Parameters:</summary>
  <pre><code>topo_df (pd.DataFrame): The topology DataFrame containing the network structure.
num_params (int, optional): The number of parameters to generate. Default is 1024.
sampling_method (Union[str, dict], optional): The sampling method to use. Can be a string
    specifying a single method for all parameters or a dictionary specifying methods for
    individual parameters. Default is "Sobol".
thr_rows (bool, optional): Whether to add threshold rows to the DataFrame. Default is True.
</code></pre>
</details>

<details class="returns:" open>
  <summary>Returns:</summary>
  <pre><code>pd.DataFrame: A DataFrame containing the parameter ranges and sampling methods.
</code></pre>
</details>

            <details class="quote">
              <summary>Source code in <code>grins/gen_params.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_param_range_df</span><span class="p">(</span>
    <span class="n">topo_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">num_params</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">sampling_method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Sobol&quot;</span><span class="p">,</span>
    <span class="n">thr_rows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a parameter range DataFrame from the topology DataFrame.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">        topo_df (pd.DataFrame): The topology DataFrame containing the network structure.</span>
<span class="sd">        num_params (int, optional): The number of parameters to generate. Default is 1024.</span>
<span class="sd">        sampling_method (Union[str, dict], optional): The sampling method to use. Can be a string</span>
<span class="sd">            specifying a single method for all parameters or a dictionary specifying methods for</span>
<span class="sd">            individual parameters. Default is &quot;Sobol&quot;.</span>
<span class="sd">        thr_rows (bool, optional): Whether to add threshold rows to the DataFrame. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">        pd.DataFrame: A DataFrame containing the parameter ranges and sampling methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate the parameter names, target nodes, and source nodes</span>
    <span class="n">param_names</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">,</span> <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">gen_param_names</span><span class="p">(</span><span class="n">topo_df</span><span class="p">)</span>
    <span class="c1"># Create a DataFrame to store the parameter ranges</span>
    <span class="n">prange_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;Parameter&quot;</span><span class="p">:</span> <span class="n">param_names</span><span class="p">})</span>
    <span class="c1"># Set the default minimum and maximum values for the parameters</span>
    <span class="n">prange_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;Prod_&quot;</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;Minimum&quot;</span><span class="p">,</span> <span class="s2">&quot;Maximum&quot;</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">]</span>
    <span class="n">prange_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;Deg_&quot;</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;Minimum&quot;</span><span class="p">,</span> <span class="s2">&quot;Maximum&quot;</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="n">prange_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;ActFld_&quot;</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;Minimum&quot;</span><span class="p">,</span> <span class="s2">&quot;Maximum&quot;</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">]</span>
    <span class="n">prange_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;InhFld_&quot;</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;Minimum&quot;</span><span class="p">,</span> <span class="s2">&quot;Maximum&quot;</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="n">prange_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;Hill&quot;</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;Minimum&quot;</span><span class="p">,</span> <span class="s2">&quot;Maximum&quot;</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">]</span>
    <span class="c1"># Set the sampling method for each parameter, if the sampling method is a dictionary set the specific method for the specified parameters</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sampling_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Sampling&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampling_method</span>
        <span class="k">if</span> <span class="n">sampling_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Normal&quot;</span><span class="p">,</span> <span class="s2">&quot;LogNormal&quot;</span><span class="p">]:</span>
            <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;StdDev&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">sampling_method</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">prange_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Parameter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">param</span><span class="p">),</span> <span class="s2">&quot;Sampling&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">method</span>
            <span class="p">)</span>
        <span class="c1"># If the sampling method is not specified for a parameter, set it to &quot;Sobol&quot;</span>
        <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Sampling&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Sampling&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;Sobol&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;Sampling&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="s2">&quot;Normal&quot;</span><span class="p">,</span> <span class="s2">&quot;LogNormal&quot;</span><span class="p">])):</span>
            <span class="n">prange_df</span><span class="p">[</span><span class="s2">&quot;StdDev&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1"># Fill the threshold rows of the parameter range DataFrame</span>
    <span class="k">if</span> <span class="n">thr_rows</span><span class="p">:</span>
        <span class="n">prange_df</span> <span class="o">=</span> <span class="n">add_thr_rows</span><span class="p">(</span><span class="n">prange_df</span><span class="p">,</span> <span class="n">topo_df</span><span class="p">,</span> <span class="n">num_params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">prange_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.gen_params.gen_param_df" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">gen_params</span><span class="o">.</span><span class="n">gen_param_df</span><span class="p">(</span><span class="n">prange_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_params</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span><span class="p">,</span> <span class="n">topo_df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampling_method</span><span class="o">=</span><span class="s1">&#39;Sobol&#39;</span><span class="p">,</span> <span class="n">thr_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generate the final parameter DataFrame by sampling parameters.
Parameters are grouped by their 'Sampling' (and 'StdDev' if present) to ensure
that parameters in the same group follow the same distribution in the higher dimensions.
The final DataFrame columns are arranged in the same order as in prange_df.
The sampling methods can be: 'Sobol', 'LHS', 'Uniform', 'LogUniform', 'Normal', 'LogNormal'.</p>
<p>Parameters:
    prange_df (pd.DataFrame): DataFrame with columns ["Parameter", "Minimum", "Maximum", "Sampling", ...].
    num_paras (int): Number of samples to generate per parameter.</p>
<p>Returns:
    pd.DataFrame: DataFrame of sampled and scaled parameters.</p>


            <details class="quote">
              <summary>Source code in <code>grins/gen_params.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_param_df</span><span class="p">(</span>
    <span class="n">prange_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">num_params</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">topo_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sampling_method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Sobol&quot;</span><span class="p">,</span>
    <span class="n">thr_rows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the final parameter DataFrame by sampling parameters.</span>
<span class="sd">    Parameters are grouped by their &#39;Sampling&#39; (and &#39;StdDev&#39; if present) to ensure</span>
<span class="sd">    that parameters in the same group follow the same distribution in the higher dimensions.</span>
<span class="sd">    The final DataFrame columns are arranged in the same order as in prange_df.</span>
<span class="sd">    The sampling methods can be: &#39;Sobol&#39;, &#39;LHS&#39;, &#39;Uniform&#39;, &#39;LogUniform&#39;, &#39;Normal&#39;, &#39;LogNormal&#39;.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        prange_df (pd.DataFrame): DataFrame with columns [&quot;Parameter&quot;, &quot;Minimum&quot;, &quot;Maximum&quot;, &quot;Sampling&quot;, ...].</span>
<span class="sd">        num_paras (int): Number of samples to generate per parameter.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: DataFrame of sampled and scaled parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If the parameter range dataframe is not given</span>
    <span class="k">if</span> <span class="n">prange_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Generating the parameter range dataframe from the topology of the network</span>
        <span class="n">prange_df</span> <span class="o">=</span> <span class="n">gen_param_range_df</span><span class="p">(</span>
            <span class="n">topo_df</span><span class="o">=</span><span class="n">topo_df</span><span class="p">,</span>
            <span class="n">num_params</span><span class="o">=</span><span class="n">num_params</span><span class="p">,</span>
            <span class="n">sampling_method</span><span class="o">=</span><span class="n">sampling_method</span><span class="p">,</span>
            <span class="n">thr_rows</span><span class="o">=</span><span class="n">thr_rows</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="c1"># # Get the ordered parameter names</span>
    <span class="c1"># ordered_params = prange_df[&quot;Parameter&quot;].tolist()</span>
    <span class="c1"># # Dictionary to store sampled values for each parameter</span>
    <span class="c1"># sampled_dict = {}</span>

    <span class="c1"># # Group by &#39;Sampling&#39; and &#39;StdDev&#39; columns</span>
    <span class="c1"># grouping_cols = [&quot;Sampling&quot;]</span>
    <span class="c1"># if &quot;StdDev&quot; in prange_df.columns:</span>
    <span class="c1">#     grouping_cols.append(&quot;StdDev&quot;)</span>

    <span class="c1"># # Iterate over the groups and sample the parameters</span>
    <span class="c1"># for _, group in prange_df.groupby(grouping_cols, sort=False):</span>
    <span class="c1">#     method = group[&quot;Sampling&quot;].iloc[0]</span>
    <span class="c1">#     std_val = group[&quot;StdDev&quot;].iloc[0] if &quot;StdDev&quot; in group.columns else None</span>
    <span class="c1">#     dims = group.shape[0]</span>
    <span class="c1">#     samples = sample_distribution(method, dims, num_paras, std_dev=std_val)</span>
    <span class="c1">#     group_sorted = group.sort_index().reset_index(drop=True)</span>
    <span class="c1">#     for i, row in group_sorted.iterrows():</span>
    <span class="c1">#         param_name = row[&quot;Parameter&quot;]</span>
    <span class="c1">#         min_val = row[&quot;Minimum&quot;]</span>
    <span class="c1">#         max_val = row[&quot;Maximum&quot;]</span>
    <span class="c1">#         col_samples = samples[:, i]</span>
    <span class="c1">#         if &quot;Hill&quot; in param_name:</span>
    <span class="c1">#             scaled = np.ceil(max_val * col_samples)</span>
    <span class="c1">#         elif &quot;InhFld&quot; in param_name:</span>
    <span class="c1">#             inv_min = 1 / max_val</span>
    <span class="c1">#             inv_max = 1 / min_val</span>
    <span class="c1">#             scaled = 1 / (inv_min + (inv_max - inv_min) * col_samples)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             scaled = min_val + (max_val - min_val) * col_samples</span>
    <span class="c1">#         sampled_dict[param_name] = scaled</span>
    <span class="c1"># # Create a DataFrame from the sampled values</span>
    <span class="c1"># data = {param: sampled_dict[param] for param in ordered_params}</span>
    <span class="c1"># # Return the DataFrame with the original parameter order</span>
    <span class="c1"># return pd.DataFrame(data, columns=ordered_params)</span>
    <span class="c1"># Use the sample_param_df function to sample the parameters</span>
    <span class="n">param_df</span> <span class="o">=</span> <span class="n">sample_param_df</span><span class="p">(</span><span class="n">prange_df</span><span class="p">,</span> <span class="n">num_params</span><span class="p">)</span>
    <span class="c1"># Add the ParamNum column to the DataFrame</span>
    <span class="c1"># param_df[&quot;ParamNum&quot;] = param_df.index + 1</span>
    <span class="n">param_df</span> <span class="o">=</span> <span class="n">param_df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">ParamNum</span><span class="o">=</span><span class="n">param_df</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">param_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.gen_params.gen_init_cond" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">gen_params</span><span class="o">.</span><span class="n">gen_init_cond</span><span class="p">(</span><span class="n">topo_df</span><span class="p">,</span> <span class="n">num_init_conds</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generate initial conditions for each node based on the topology.</p>
<p>Parameters:
    topo_df (pd.DataFrame): A DataFrame containing the topology information.
    num_init_conds (int, optional): The number of initial conditions to generate. Defaults to 1000.</p>
<p>Returns:
    pd.DataFrame: A DataFrame containing the generated initial conditions for each node.</p>


            <details class="quote">
              <summary>Source code in <code>grins/gen_params.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_init_cond</span><span class="p">(</span><span class="n">topo_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">num_init_conds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate initial conditions for each node based on the topology.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        topo_df (pd.DataFrame): A DataFrame containing the topology information.</span>
<span class="sd">        num_init_conds (int, optional): The number of initial conditions to generate. Defaults to 1000.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame containing the generated initial conditions for each node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">,</span> <span class="n">source_nodes</span> <span class="o">=</span> <span class="n">gen_param_names</span><span class="p">(</span><span class="n">topo_df</span><span class="p">)</span>
    <span class="n">unique_nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">source_nodes</span> <span class="o">+</span> <span class="n">target_nodes</span><span class="p">))</span>
    <span class="n">init_conds</span> <span class="o">=</span> <span class="n">_gen_sobol_seq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_nodes</span><span class="p">),</span> <span class="n">num_init_conds</span><span class="p">)</span>
    <span class="c1"># Scale initial conditions between 1 and 100</span>
    <span class="n">init_conds</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">init_conds</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">initcond_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">init_conds</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">unique_nodes</span><span class="p">)</span>
    <span class="c1"># A new columns for the intial condition numbers</span>
    <span class="c1"># initcond_df[&quot;InitCondNum&quot;] = initcond_df.index + 1</span>
    <span class="n">initcond_df</span> <span class="o">=</span> <span class="n">initcond_df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">InitCondNum</span><span class="o">=</span><span class="n">initcond_df</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">initcond_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><hr />
<h2 id="simulation-related-functions">Simulation Related Functions</h2>
<hr />


<div class="doc doc-object doc-function">


<h2 id="grins.racipe_run.gen_sim_dirstruct" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">racipe_run</span><span class="o">.</span><span class="n">gen_sim_dirstruct</span><span class="p">(</span><span class="n">topo_file</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">num_replicates</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generate directory structure for simulation run.</p>
<p>Parameters:
    topo_file (str): Path to the topo file.
    save_dir (str, optional): Directory to save the generated structure. Defaults to ".".
    num_replicates (int, optional): Number of replicates to generate. Defaults to 3.
Returns:
    Directory structure is created with the topo file name and three folders for the replicates.</p>


            <details class="quote">
              <summary>Source code in <code>grins/racipe_run.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_sim_dirstruct</span><span class="p">(</span>
    <span class="n">topo_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate directory structure for simulation run.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        topo_file (str): Path to the topo file.</span>
<span class="sd">        save_dir (str, optional): Directory to save the generated structure. Defaults to &quot;.&quot;.</span>
<span class="sd">        num_replicates (int, optional): Number of replicates to generate. Defaults to 3.</span>
<span class="sd">    Returns:</span>
<span class="sd">        Directory structure is created with the topo file name and three folders for the replicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the topo file name</span>
    <span class="n">topo_name</span> <span class="o">=</span> <span class="n">topo_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Check if the folder with the name of topo file exists</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Move the topo file to the created folder</span>
    <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s2">&quot;cp&quot;</span><span class="p">,</span>
            <span class="n">topo_file</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="c1"># Make the replicate directories</span>
    <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_replicates</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">rep</span><span class="si">:</span><span class="s2">03</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.racipe_run.gen_topo_param_files" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">racipe_run</span><span class="o">.</span><span class="n">gen_topo_param_files</span><span class="p">(</span><span class="n">topo_file</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">num_replicates</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_params</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span><span class="p">,</span> <span class="n">num_init_conds</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="n">sampling_method</span><span class="o">=</span><span class="s1">&#39;Sobol&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Generate parameter files for simulation.</p>
<p>Parameters:
    topo_file (str): The path to the topo file.
    save_dir (str, optional): The directory where the parameter files will be saved. Defaults to ".".
    num_params (int, optional): The number of parameter files to generate. Defaults to 2<strong>10.
    num_init_conds (int, optional): The number of initial condition files to generate. Defaults to 2</strong>7.
    sampling_method (Union[str, dict], optional): The method to use for sampling the parameter space. Defaults to 'Sobol'. For a finer control over the parameter generation look at the documentation of the gen_param_range_df function and gen_param_df function.
Returns:
    The parameter files and initial conditions are generated and saved in the specified replicate directories.</p>


            <details class="quote">
              <summary>Source code in <code>grins/racipe_run.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gen_topo_param_files</span><span class="p">(</span>
    <span class="n">topo_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">save_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">num_params</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">num_init_conds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">7</span><span class="p">,</span>
    <span class="n">sampling_method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Sobol&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate parameter files for simulation.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        topo_file (str): The path to the topo file.</span>
<span class="sd">        save_dir (str, optional): The directory where the parameter files will be saved. Defaults to &quot;.&quot;.</span>
<span class="sd">        num_params (int, optional): The number of parameter files to generate. Defaults to 2**10.</span>
<span class="sd">        num_init_conds (int, optional): The number of initial condition files to generate. Defaults to 2**7.</span>
<span class="sd">        sampling_method (Union[str, dict], optional): The method to use for sampling the parameter space. Defaults to &#39;Sobol&#39;. For a finer control over the parameter generation look at the documentation of the gen_param_range_df function and gen_param_df function.</span>
<span class="sd">    Returns:</span>
<span class="sd">        The parameter files and initial conditions are generated and saved in the specified replicate directories.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the name of the topo file</span>
    <span class="n">topo_name</span> <span class="o">=</span> <span class="n">topo_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Parse the topo file</span>
    <span class="n">topo_df</span> <span class="o">=</span> <span class="n">parse_topos</span><span class="p">(</span><span class="n">topo_file</span><span class="p">)</span>
    <span class="c1"># # Generate the parameter names</span>
    <span class="c1"># param_names = gen_param_names(topo_df)</span>
    <span class="c1"># Get the unique nodes in the topo file</span>
    <span class="c1"># unique_nodes = sorted(set(param_names[1] + param_names[2]))</span>
    <span class="c1"># Generate the required directory structure</span>
    <span class="n">gen_sim_dirstruct</span><span class="p">(</span><span class="n">topo_file</span><span class="p">,</span> <span class="n">save_dir</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">)</span>
    <span class="c1"># Specify directory where all the generated ode system file will be saved</span>
    <span class="n">sim_dir</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="c1"># Generate the ODE system for diffrax</span>
    <span class="n">gen_diffrax_odesys</span><span class="p">(</span><span class="n">topo_df</span><span class="p">,</span> <span class="n">topo_name</span><span class="p">,</span> <span class="n">sim_dir</span><span class="p">)</span>
    <span class="c1"># Generate the parameter dataframe and save in each of the replicate folders</span>
    <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_replicates</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Generate the parameter range dataframe</span>
        <span class="n">param_range_df</span> <span class="o">=</span> <span class="n">gen_param_range_df</span><span class="p">(</span>
            <span class="n">topo_df</span><span class="p">,</span> <span class="n">num_params</span><span class="p">,</span> <span class="n">sampling_method</span><span class="o">=</span><span class="n">sampling_method</span>
        <span class="p">)</span>
        <span class="c1"># Save the parameter range dataframe</span>
        <span class="n">param_range_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sim_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">rep</span><span class="si">:</span><span class="s2">03</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_param_range_</span><span class="si">{</span><span class="n">rep</span><span class="si">:</span><span class="s2">03</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># # Generate the parameter dataframe with the default values</span>
        <span class="n">param_df</span> <span class="o">=</span> <span class="n">gen_param_df</span><span class="p">(</span><span class="n">param_range_df</span><span class="p">,</span> <span class="n">num_params</span><span class="p">)</span>
        <span class="c1"># print(param_df)</span>
        <span class="n">param_df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sim_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">rep</span><span class="si">:</span><span class="s2">03</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_params_</span><span class="si">{</span><span class="n">rep</span><span class="si">:</span><span class="s2">03</span><span class="si">}</span><span class="s2">.parquet&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="c1"># Generate the initial conditions dataframe</span>
        <span class="n">initcond_df</span> <span class="o">=</span> <span class="n">gen_init_cond</span><span class="p">(</span><span class="n">topo_df</span><span class="o">=</span><span class="n">topo_df</span><span class="p">,</span> <span class="n">num_init_conds</span><span class="o">=</span><span class="n">num_init_conds</span><span class="p">)</span>
        <span class="c1"># print(initcond_df)</span>
        <span class="n">initcond_df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sim_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">rep</span><span class="si">:</span><span class="s2">03</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_init_conds_</span><span class="si">{</span><span class="n">rep</span><span class="si">:</span><span class="s2">03</span><span class="si">}</span><span class="s2">.parquet&quot;</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter and Intial Condition files generated for </span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.racipe_run.load_odeterm" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">racipe_run</span><span class="o">.</span><span class="n">load_odeterm</span><span class="p">(</span><span class="n">topo_name</span><span class="p">,</span> <span class="n">simdir</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Loads an ODE system from a specified topology module and returns an ODETerm object.</p>
<p>Parameters:
    topo_name (str): The name of the topology module to import.
    simdir (str): The directory path where the topology module is located.</p>
<p>Returns:
    ODETerm: An object representing the ODE system.</p>
<p>Raises:
    ImportError: If the specified module cannot be imported.
    AttributeError: If the module does not contain an attribute named 'odesys'.</p>


            <details class="quote">
              <summary>Source code in <code>grins/racipe_run.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">load_odeterm</span><span class="p">(</span><span class="n">topo_name</span><span class="p">,</span> <span class="n">simdir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads an ODE system from a specified topology module and returns an ODETerm object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        topo_name (str): The name of the topology module to import.</span>
<span class="sd">        simdir (str): The directory path where the topology module is located.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ODETerm: An object representing the ODE system.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ImportError: If the specified module cannot be imported.</span>
<span class="sd">        AttributeError: If the module does not contain an attribute named &#39;odesys&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">simdir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">term</span> <span class="o">=</span> <span class="n">ODETerm</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="s2">&quot;odesys&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">term</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.racipe_run.topo_simulate" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">racipe_run</span><span class="o">.</span><span class="n">topo_simulate</span><span class="p">(</span><span class="n">topo_file</span><span class="p">,</span> <span class="n">replicate_dir</span><span class="p">,</span> <span class="n">initial_conditions</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span> <span class="n">dt0</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">tsteps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-06</span><span class="p">,</span> <span class="n">max_steps</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">ode_term_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Simulates the ODE system defined by the topology file and saves the results in the replicate directory. The ode system is loaded as a diffrax ode term and the initial conditions and parameters are passed as jax arrays. The simulation is run for the specified time range and time steps and the results are saved in parquet format in the replicate directory.</p>
<p>Parameters:
    topo_file (str): Path to the topology file.
    replicate_dir (str): Directory where the replicate results will be saved.
    initial_conditions (pd.DataFrame): DataFrame containing the initial conditions.
    parameters (pd.DataFrame): DataFrame containing the parameters.
    t0 (float, optional): Initial time for the simulation. Default is 0.0.
    tmax (float, optional): Maximum time for the simulation. Default is 100.0.
    dt0 (float, optional): Initial time step size. Default is 0.1.
    tsteps (list, optional): List of time steps at which to save the results. Default is None.
    rel_tol (float, optional): Relative tolerance for the ODE solver. Default is 1e-5.
    abs_tol (float, optional): Absolute tolerance for the ODE solver. Default is 1e-6.
    max_steps (int, optional): Maximum number of steps for the ODE solver. Default is 2048.
    batch_size (int, optional): Batch size for processing combinations of initial conditions and parameters. Default is 10000.
    ode_term_dir (str, optional): Directory where the ODE system file is located. Default is None. If None, the parent directory of the replicate directory is assumed to contain the ODE system file. The ODE system file should be named as the topo file with the .py extension.</p>
<p>Returns:
    pd.DataFrame: DataFrame containing the solutions of the ODE system.</p>


            <details class="quote">
              <summary>Source code in <code>grins/racipe_run.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">topo_simulate</span><span class="p">(</span>
    <span class="n">topo_file</span><span class="p">,</span>
    <span class="n">replicate_dir</span><span class="p">,</span>
    <span class="n">initial_conditions</span><span class="p">,</span>
    <span class="n">parameters</span><span class="p">,</span>
    <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">tmax</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span>
    <span class="n">dt0</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">tsteps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">max_steps</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
    <span class="n">ode_term_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates the ODE system defined by the topology file and saves the results in the replicate directory. The ode system is loaded as a diffrax ode term and the initial conditions and parameters are passed as jax arrays. The simulation is run for the specified time range and time steps and the results are saved in parquet format in the replicate directory.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        topo_file (str): Path to the topology file.</span>
<span class="sd">        replicate_dir (str): Directory where the replicate results will be saved.</span>
<span class="sd">        initial_conditions (pd.DataFrame): DataFrame containing the initial conditions.</span>
<span class="sd">        parameters (pd.DataFrame): DataFrame containing the parameters.</span>
<span class="sd">        t0 (float, optional): Initial time for the simulation. Default is 0.0.</span>
<span class="sd">        tmax (float, optional): Maximum time for the simulation. Default is 100.0.</span>
<span class="sd">        dt0 (float, optional): Initial time step size. Default is 0.1.</span>
<span class="sd">        tsteps (list, optional): List of time steps at which to save the results. Default is None.</span>
<span class="sd">        rel_tol (float, optional): Relative tolerance for the ODE solver. Default is 1e-5.</span>
<span class="sd">        abs_tol (float, optional): Absolute tolerance for the ODE solver. Default is 1e-6.</span>
<span class="sd">        max_steps (int, optional): Maximum number of steps for the ODE solver. Default is 2048.</span>
<span class="sd">        batch_size (int, optional): Batch size for processing combinations of initial conditions and parameters. Default is 10000.</span>
<span class="sd">        ode_term_dir (str, optional): Directory where the ODE system file is located. Default is None. If None, the parent directory of the replicate directory is assumed to contain the ODE system file. The ODE system file should be named as the topo file with the .py extension.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: DataFrame containing the solutions of the ODE system.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the name of the topo file</span>
    <span class="n">topo_name</span> <span class="o">=</span> <span class="n">topo_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Making sure to remove the trailing slash from the replicate directory path if it exists</span>
    <span class="n">replicate_dir</span> <span class="o">=</span> <span class="n">replicate_dir</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="c1"># Check if the ode term directory is None</span>
    <span class="k">if</span> <span class="n">ode_term_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Getting the parent directory of the replicate directory to get the ODE system file</span>
        <span class="n">simul_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">replicate_dir</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading ODE system from: </span><span class="si">{</span><span class="n">simul_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Making sure to remove the trailing slash from the ode term directory path if it exists</span>
        <span class="n">simul_dir</span> <span class="o">=</span> <span class="n">ode_term_dir</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="c1"># Load the ODE system as a diffrax ode term</span>
    <span class="n">ode_term</span> <span class="o">=</span> <span class="n">load_odeterm</span><span class="p">(</span><span class="n">topo_name</span><span class="p">,</span> <span class="n">simul_dir</span><span class="p">)</span>
    <span class="c1"># Getting the intial conditions dataframe column names</span>
    <span class="n">ic_columns</span> <span class="o">=</span> <span class="n">initial_conditions</span><span class="o">.</span><span class="n">columns</span>
    <span class="c1"># Converting the initial conditions and parameters to jax arrays</span>
    <span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_conditions</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
    <span class="c1"># Get the combinations of initial conditions and parameters</span>
    <span class="n">icprm_comb</span> <span class="o">=</span> <span class="n">_gen_combinations</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of combinations to simulate: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">icprm_comb</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Processing the time steps</span>
    <span class="k">if</span> <span class="n">tsteps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">saveat</span> <span class="o">=</span> <span class="n">SaveAt</span><span class="p">(</span><span class="n">t1</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Running steady sate simulations for replicate: </span><span class="si">{</span><span class="n">replicate_dir</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Checking if the time steps are in the correct format</span>
        <span class="n">tsteps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tsteps</span><span class="p">)</span>
        <span class="c1"># If the final step more than tmax, make tmax equal to the final step</span>
        <span class="k">if</span> <span class="n">tsteps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tmax</span><span class="p">:</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="n">tsteps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Convert the time steps to a jax array</span>
        <span class="n">tsteps</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tsteps</span><span class="p">)</span>
        <span class="c1"># Make the saveat object be the time steps</span>
        <span class="n">saveat</span> <span class="o">=</span> <span class="n">SaveAt</span><span class="p">(</span><span class="n">ts</span><span class="o">=</span><span class="n">tsteps</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Running time series simulations for replicate: </span><span class="si">{</span><span class="n">replicate_dir</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="c1"># Specifying the PID controller for the step sizes</span>
    <span class="n">stepsize_controller</span> <span class="o">=</span> <span class="n">PIDController</span><span class="p">(</span><span class="n">rtol</span><span class="o">=</span><span class="n">rel_tol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">abs_tol</span><span class="p">)</span>
    <span class="c1"># Get the functions to solve the ODE system</span>
    <span class="n">solveode_fn</span> <span class="o">=</span> <span class="n">parameterise_solveode</span><span class="p">(</span>
        <span class="n">ode_term</span><span class="p">,</span>
        <span class="n">Tsit5</span><span class="p">(),</span>
        <span class="n">t0</span><span class="p">,</span>
        <span class="n">tmax</span><span class="p">,</span>
        <span class="n">dt0</span><span class="p">,</span>
        <span class="n">saveat</span><span class="p">,</span>
        <span class="n">stepsize_controller</span><span class="p">,</span>
        <span class="n">max_steps</span><span class="p">,</span>
        <span class="n">initial_conditions</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Jit compile the solveode function</span>
    <span class="n">solveode_fn</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">solveode_fn</span><span class="p">)</span>
    <span class="c1"># # # Solve for one combination of initial conditions and parameters</span>
    <span class="c1"># sol = solveode_fn(icprm_comb[0])</span>
    <span class="c1"># print(sol)</span>
    <span class="c1"># Create an empty array to store the solutions</span>
    <span class="k">if</span> <span class="n">saveat</span><span class="o">.</span><span class="n">subs</span><span class="o">.</span><span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">solution_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">icprm_comb</span><span class="p">),</span> <span class="n">initial_conditions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solution_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">icprm_comb</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">saveat</span><span class="o">.</span><span class="n">subs</span><span class="o">.</span><span class="n">ts</span><span class="p">),</span> <span class="n">initial_conditions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="c1"># Defining the length of the time steps to properly index the solution matrix</span>
    <span class="n">len_tsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">saveat</span><span class="o">.</span><span class="n">subs</span><span class="o">.</span><span class="n">ts</span><span class="p">)</span> <span class="k">if</span> <span class="n">saveat</span><span class="o">.</span><span class="n">subs</span><span class="o">.</span><span class="n">ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="c1"># Iterate over the combinations array in batches</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">icprm_comb</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="c1"># print(ip)</span>
        <span class="c1"># Get the chunk of the combinations array</span>
        <span class="n">icprm_chunk</span> <span class="o">=</span> <span class="n">icprm_comb</span><span class="p">[</span><span class="n">ip</span> <span class="p">:</span> <span class="n">ip</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">]</span>
        <span class="c1"># vmap the solveode function over the chunk of the combinations array</span>
        <span class="n">sols</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">solveode_fn</span><span class="p">)(</span><span class="n">icprm_chunk</span><span class="p">)</span>
        <span class="c1"># Vertically stack the solutions</span>
        <span class="n">sols</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span>
        <span class="c1"># Round the solutions to 4 decimal places</span>
        <span class="n">sols</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sols</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="c1"># print(ip * len(saveat.subs.ts), (ip * len(saveat.subs.ts)) + len(sols))</span>
        <span class="c1"># Add the solutions to the solution matrix at the correct index</span>
        <span class="n">solution_matrix</span><span class="p">[</span><span class="n">ip</span> <span class="o">*</span> <span class="n">len_tsteps</span> <span class="p">:</span> <span class="p">(</span><span class="n">ip</span> <span class="o">*</span> <span class="n">len_tsteps</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sols</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">sols</span>
        <span class="p">)</span>
    <span class="c1"># Convert the solution matrix to a dataframe</span>
    <span class="c1"># REmoving the InitCondNum column from the initial conditions</span>
    <span class="k">if</span> <span class="n">saveat</span><span class="o">.</span><span class="n">subs</span><span class="o">.</span><span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">solution_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">solution_matrix</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">ic_columns</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span> <span class="s2">&quot;SteadyStateFlag&quot;</span><span class="p">,</span> <span class="s2">&quot;InitCondNum&quot;</span><span class="p">,</span> <span class="s2">&quot;ParamNum&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># Find number of steady state solutions</span>
        <span class="c1"># print(solution_matrix[&quot;SteadyStateFlag&quot;].value_counts())</span>
        <span class="c1"># # Make the steady state flag, init cond and param num columns into integers</span>
        <span class="c1"># solution_matrix[[&quot;SteadyStateFlag&quot;, &quot;InitCondNum&quot;, &quot;ParamNum&quot;]] = (</span>
        <span class="c1">#     solution_matrix[[&quot;SteadyStateFlag&quot;, &quot;InitCondNum&quot;, &quot;ParamNum&quot;]].astype(int)</span>
        <span class="c1"># )</span>
        <span class="c1"># # Save the solution matrix as a parquet file</span>
        <span class="c1"># solution_matrix.to_parquet(</span>
        <span class="c1">#     f&quot;{replicate_dir}/{topo_name}_steadystate_solutions.parquet&quot;, index=False</span>
        <span class="c1"># )</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solution_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">solution_matrix</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">ic_columns</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span> <span class="s2">&quot;InitCondNum&quot;</span><span class="p">,</span> <span class="s2">&quot;ParamNum&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># # Make the init cond and param num columns into integers</span>
        <span class="c1"># solution_matrix[[&quot;InitCondNum&quot;, &quot;ParamNum&quot;]] = solution_matrix[</span>
        <span class="c1">#     [&quot;InitCondNum&quot;, &quot;ParamNum&quot;]</span>
        <span class="c1"># ].astype(int)</span>
        <span class="c1"># Find number of last time points</span>
        <span class="c1"># print(solution_matrix[&quot;Time&quot;].value_counts())</span>
        <span class="c1"># Save the solution matrix as a parquet file</span>
        <span class="c1"># solution_matrix.to_parquet(</span>
        <span class="c1">#     f&quot;{replicate_dir}/{topo_name}_timeseries_solutions.parquet&quot;, index=False</span>
        <span class="c1"># )</span>
    <span class="k">return</span> <span class="n">solution_matrix</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.racipe_run.gk_normalise_solutions" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">racipe_run</span><span class="o">.</span><span class="n">gk_normalise_solutions</span><span class="p">(</span><span class="n">sol_df</span><span class="p">,</span> <span class="n">param_df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.01</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Normalises the solutions in the solution dataframe using the maximum production rate (G) and degradation rate (k) parameters of the individual nodes in the parameter sets.</p>
<p>Parameters:
    sol_df (pd.DataFrame): DataFrame containing the solutions with a 'ParamNum' column to join with param_df.
    param_df (pd.DataFrame): DataFrame containing the parameters with 'Prod_' and 'Deg_' columns for each node.
    threshold (float, optional): Threshold value for discretising the solutions. Default is 1.01.</p>
<p>Returns:
    pd.DataFrame: A DataFrame with normalised and discretized solutions.
    pd.DataFrame: A DataFrame containing the counts of each state in the normalised solutions</p>
<p>Example:
First, run the simulation then, normalise and discretise the solutions</p>
<p>'''python</p>
<blockquote>
<blockquote>
<blockquote>
<p>sol_df, state_counts = gk_normalise_solutions(sol_df, params)
'''</p>
</blockquote>
</blockquote>
</blockquote>
<p>Here, the 'sol_df' is the solution dataframe and 'params' is the parameter dataframe.
The 'state_counts' dataframe contains the counts of each state in the normalised solutions. The returned 'sol_df' is the normalised and discretised solution dataframe.</p>


            <details class="quote">
              <summary>Source code in <code>grins/racipe_run.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gk_normalise_solutions</span><span class="p">(</span><span class="n">sol_df</span><span class="p">,</span> <span class="n">param_df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.01</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalises the solutions in the solution dataframe using the maximum production rate (G) and degradation rate (k) parameters of the individual nodes in the parameter sets.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        sol_df (pd.DataFrame): DataFrame containing the solutions with a &#39;ParamNum&#39; column to join with param_df.</span>
<span class="sd">        param_df (pd.DataFrame): DataFrame containing the parameters with &#39;Prod_&#39; and &#39;Deg_&#39; columns for each node.</span>
<span class="sd">        threshold (float, optional): Threshold value for discretising the solutions. Default is 1.01.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame with normalised and discretized solutions.</span>
<span class="sd">        pd.DataFrame: A DataFrame containing the counts of each state in the normalised solutions</span>

<span class="sd">    Example:</span>
<span class="sd">    First, run the simulation then, normalise and discretise the solutions</span>

<span class="sd">    &#39;&#39;&#39;python</span>
<span class="sd">    &gt;&gt;&gt; sol_df, state_counts = gk_normalise_solutions(sol_df, params)</span>
<span class="sd">    &#39;&#39;&#39;</span>

<span class="sd">    Here, the &#39;sol_df&#39; is the solution dataframe and &#39;params&#39; is the parameter dataframe.</span>
<span class="sd">    The &#39;state_counts&#39; dataframe contains the counts of each state in the normalised solutions. The returned &#39;sol_df&#39; is the normalised and discretised solution dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the node columns from the solution dataframe</span>
    <span class="n">node_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Prod_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">param_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s2">&quot;Prod_&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
    <span class="c1"># Get the production and degradation columns</span>
    <span class="n">prod_cols</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Prod_</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_cols</span><span class="p">]</span>
    <span class="n">deg_cols</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Deg_</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_cols</span><span class="p">]</span>
    <span class="c1"># Get the gk columns</span>
    <span class="n">gk_cols</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;gk_</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_cols</span><span class="p">]</span>
    <span class="c1"># Compute the gk values</span>
    <span class="n">param_df</span><span class="p">[</span><span class="n">gk_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_df</span><span class="p">[</span><span class="n">prod_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">param_df</span><span class="p">[</span><span class="n">deg_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># Join the solution dataframe with the parameter dataframe on the &#39;ParamNum&#39; column</span>
    <span class="n">norm_df</span> <span class="o">=</span> <span class="n">sol_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">param_df</span><span class="p">[</span><span class="n">gk_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;ParamNum&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;ParamNum&quot;</span><span class="p">)</span>
    <span class="c1"># Divide the node columns by the gk columns</span>
    <span class="n">norm_df</span><span class="p">[</span><span class="n">gk_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm_df</span><span class="p">[</span><span class="n">node_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">norm_df</span><span class="p">[</span><span class="n">gk_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">discretize</span><span class="p">:</span>
        <span class="c1"># Select the node columns and discretise the solutions</span>
        <span class="n">norm_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">norm_df</span><span class="p">,</span> <span class="n">discretise_solutions</span><span class="p">(</span><span class="n">norm_df</span><span class="p">[</span><span class="n">gk_cols</span><span class="p">],</span> <span class="n">threshold</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
    <span class="c1"># Drop the gk columns</span>
    <span class="n">norm_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">gk_cols</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># print(norm_df)</span>
    <span class="k">if</span> <span class="n">discretize</span><span class="p">:</span>
        <span class="c1"># Get the State columns and return the state counts</span>
        <span class="n">state_counts</span> <span class="o">=</span> <span class="n">norm_df</span><span class="p">[</span><span class="s2">&quot;State&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="c1"># Make the State column as a column</span>
        <span class="n">state_counts</span> <span class="o">=</span> <span class="n">state_counts</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="c1"># Rename the columns</span>
        <span class="n">state_counts</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;State&quot;</span><span class="p">,</span> <span class="s2">&quot;Count&quot;</span><span class="p">]</span>
        <span class="c1"># Return the normalised and discretised solution dataframe</span>
        <span class="k">return</span> <span class="n">norm_df</span><span class="p">,</span> <span class="n">state_counts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">norm_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.racipe_run.discretise_solutions" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">racipe_run</span><span class="o">.</span><span class="n">discretise_solutions</span><span class="p">(</span><span class="n">norm_df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.01</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Discretises the solutions in a g/k normalized DataFrame based on histogram peaks and minima.</p>
<p>Parameters:
    norm_df (pd.DataFrame): A DataFrame containing normalized values to be discretised.
    threshold (float): A hard threshold value to clip the values in the DataFrame. Default is 1.01. Ih the parameter sets are in such a way that the maximum possible expression of the node is not prduction/degradation, then the threshold value needs to be adjusted accordingly.</p>
<p>Returns:
    pd.Series: A Series containing the discrete state labels for each row in the input DataFrame.</p>
<p>Raises:
    ValueError: If any value in the DataFrame exceeds the specified threshold.</p>
<p>Example:
Given a normalized DataFrame 'norm_df', discretise the values</p>
<p>'''python</p>
<blockquote>
<blockquote>
<blockquote>
<p>lvl_df = discretise_solutions(norm_df)
'''</p>
</blockquote>
</blockquote>
</blockquote>
<p>The normalised solution dataframe will have vlaues of the nodes bewteen 0 (lowest) and 1 (highest) and the returned 'lvl_df' will have the discrete state labels for each row in the input DataFrame.</p>


            <details class="quote">
              <summary>Source code in <code>grins/racipe_run.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">discretise_solutions</span><span class="p">(</span><span class="n">norm_df</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Discretises the solutions in a g/k normalized DataFrame based on histogram peaks and minima.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        norm_df (pd.DataFrame): A DataFrame containing normalized values to be discretised.</span>
<span class="sd">        threshold (float): A hard threshold value to clip the values in the DataFrame. Default is 1.01. Ih the parameter sets are in such a way that the maximum possible expression of the node is not prduction/degradation, then the threshold value needs to be adjusted accordingly.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.Series: A Series containing the discrete state labels for each row in the input DataFrame.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If any value in the DataFrame exceeds the specified threshold.</span>

<span class="sd">    Example:</span>
<span class="sd">    Given a normalized DataFrame &#39;norm_df&#39;, discretise the values</span>


<span class="sd">    &#39;&#39;&#39;python</span>
<span class="sd">    &gt;&gt;&gt; lvl_df = discretise_solutions(norm_df)</span>
<span class="sd">    &#39;&#39;&#39;</span>

<span class="sd">    The normalised solution dataframe will have vlaues of the nodes bewteen 0 (lowest) and 1 (highest) and the returned &#39;lvl_df&#39; will have the discrete state labels for each row in the input DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Flatten the numeric part of the dataframe (columns 4 onwards)</span>
    <span class="n">flat</span> <span class="o">=</span> <span class="n">norm_df</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Add dummy values to ensure boundary peaks are detected</span>
    <span class="n">dummy_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">dummy_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
    <span class="n">data_with_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">dummy_low</span><span class="p">,</span> <span class="n">flat</span><span class="p">,</span> <span class="n">dummy_high</span><span class="p">])</span>

    <span class="c1"># Compute histogram over 120 bins</span>
    <span class="n">flat_hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data_with_dummy</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">120</span><span class="p">)</span>

    <span class="c1"># Define threshold for peak and minima detection (1% of data length)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">)</span>

    <span class="c1"># Detect peaks in the histogram</span>
    <span class="n">peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span>
        <span class="n">flat_hist</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">prominence</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
        <span class="n">distance</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">maxima_bins</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">peaks</span><span class="p">]</span>

    <span class="c1"># Detect minima by inverting the histogram (skip first and last bin)</span>
    <span class="n">minima_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">flat_hist</span><span class="p">)</span> <span class="o">-</span> <span class="n">flat_hist</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">height</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">flat_hist</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.99</span>
    <span class="p">)</span>
    <span class="c1"># Adjust indices (because we skipped the first bin)</span>
    <span class="n">minima_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">minima_indices</span><span class="p">]</span>

    <span class="c1"># Initialize minima bins with the boundaries 0.0 and 1.0</span>
    <span class="n">minima_bins</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

    <span class="c1"># For multiple peaks, find a representative (median) minimum between each adjacent pair</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima_bins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima_bins</span><span class="p">)):</span>
            <span class="c1"># Candidate minima between two successive peaks</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">bin_edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">minima_indices</span>
                <span class="k">if</span> <span class="n">maxima_bins</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">maxima_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="n">median_candidate</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">minima_bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">median_candidate</span><span class="p">)</span>
    <span class="c1"># If only one peak exists, take the median minimum if available</span>
    <span class="k">elif</span> <span class="n">minima_indices</span><span class="p">:</span>
        <span class="n">median_candidate</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">minima_indices</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">minima_indices</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]]</span>
        <span class="n">minima_bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">median_candidate</span><span class="p">)</span>

    <span class="c1"># Ensure the bin edges are sorted</span>
    <span class="n">minima_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">minima_bins</span><span class="p">)</span>

    <span class="c1"># Clip the values to 1.0 as due to small numerical errors, some values may be slightly above 1.0</span>
    <span class="n">norm_df</span> <span class="o">=</span> <span class="n">norm_df</span><span class="o">.</span><span class="n">mask</span><span class="p">((</span><span class="n">norm_df</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">norm_df</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># If any value is found to be higher than the hard threshold, raise an error</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">norm_df</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some values exceed the hard threshold of </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">, check your input data.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Use vectorized binning to assign each value to a discrete level</span>
    <span class="c1"># The number of levels is len(minima_bins)-1 (each interval defines one level)</span>
    <span class="n">lvl_df</span> <span class="o">=</span> <span class="n">norm_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">col</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span>
            <span class="n">col</span><span class="p">,</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">minima_bins</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima_bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">include_lowest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">lvl_df</span> <span class="o">=</span> <span class="n">lvl_df</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="s2">&quot;Lvl_&quot;</span><span class="p">)</span>

    <span class="c1"># Create a &#39;State&#39; column by concatenating the discrete levels as strings</span>
    <span class="n">lvl_df</span><span class="p">[</span><span class="s2">&quot;State&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">lvl_df</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
    <span class="c1"># print(lvl_df)</span>
    <span class="c1"># Get the value counts of the states</span>
    <span class="c1"># print(lvl_df[&quot;State&quot;].value_counts())</span>
    <span class="k">return</span> <span class="n">lvl_df</span><span class="p">[</span><span class="s2">&quot;State&quot;</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="grins.racipe_run.run_all_replicates" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">grins</span><span class="o">.</span><span class="n">racipe_run</span><span class="o">.</span><span class="n">run_all_replicates</span><span class="p">(</span><span class="n">topo_file</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span> <span class="n">dt0</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">tsteps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-06</span><span class="p">,</span> <span class="n">max_steps</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents first">

        <p>Run simulations for all replicates of the specified topo file. The initial conditions and parameters are loaded from the replicate folders. The directory structure is assumed to be the same as that generated by the gen_topo_param_files function, with the main directory with the topo file name which has the parameter range file the ODE system file and the replicate folders with the initial conditions and parameters dataframes.</p>
<p>Parameters:
topo_file (str): Path to the topology file.
save_dir (str, optional): Directory where the replicate folders are saved. Defaults to ".".
t0 (float, optional): Initial time for the simulation. Defaults to 0.0.
tmax (float, optional): Maximum time for the simulation. Defaults to 100.0.
dt0 (float, optional): Initial time step for the simulation. Defaults to 0.1.
tsteps (int, optional): Number of time steps for the simulation. Defaults to None.
rel_tol (float, optional): Relative tolerance for the simulation. Defaults to 1e-5.
abs_tol (float, optional): Absolute tolerance for the simulation. Defaults to 1e-6.
max_steps (int, optional): Maximum number of steps for the simulation. Defaults to 2048.
batch_size (int, optional): Batch size for the simulation. Defaults to 1000.
normalize (bool, optional): Whether to normalise the solutions. Defaults to True.
discretize (bool, optional): Whether to discretize the solutions. Defaults to True.</p>
<p>Returns:
None</p>
<p>Note:
The results of the simulation are saved in the replicate folders in the specified directory. If the simulation is time series, the results are saved as 'timeseries_solutions.parquet' and if the simulation is steady state, the results are saved as 'steadystate_solutions.parquet'.</p>
<p>Normalisation and discretisation of the solutions are optional. But to discretise the solutions, the normalisation is required.</p>
<p>If the discretize flag is set to True, the solutions are discretized and the state counts are saved as 'state_counts.csv', this is only applicable for steady state simulations. If the discretize flag is set to False, the solutions are normalised but not discretized.</p>
<p>Example:
Run the simulation for the specified topo file</p>
<p>'''python</p>
<blockquote>
<blockquote>
<blockquote>
<p>run_all_replicates(topo_file, save_dir, t0, tmax, dt0, tsteps, rel_tol, abs_tol, max_steps, batch_size)
'''</p>
</blockquote>
</blockquote>
</blockquote>


            <details class="quote">
              <summary>Source code in <code>grins/racipe_run.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_all_replicates</span><span class="p">(</span>
    <span class="n">topo_file</span><span class="p">,</span>
    <span class="n">save_dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
    <span class="n">t0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">tmax</span><span class="o">=</span><span class="mf">200.0</span><span class="p">,</span>
    <span class="n">dt0</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
    <span class="n">tsteps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
    <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">max_steps</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
    <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">discretize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run simulations for all replicates of the specified topo file. The initial conditions and parameters are loaded from the replicate folders. The directory structure is assumed to be the same as that generated by the gen_topo_param_files function, with the main directory with the topo file name which has the parameter range file the ODE system file and the replicate folders with the initial conditions and parameters dataframes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    topo_file (str): Path to the topology file.</span>
<span class="sd">    save_dir (str, optional): Directory where the replicate folders are saved. Defaults to &quot;.&quot;.</span>
<span class="sd">    t0 (float, optional): Initial time for the simulation. Defaults to 0.0.</span>
<span class="sd">    tmax (float, optional): Maximum time for the simulation. Defaults to 100.0.</span>
<span class="sd">    dt0 (float, optional): Initial time step for the simulation. Defaults to 0.1.</span>
<span class="sd">    tsteps (int, optional): Number of time steps for the simulation. Defaults to None.</span>
<span class="sd">    rel_tol (float, optional): Relative tolerance for the simulation. Defaults to 1e-5.</span>
<span class="sd">    abs_tol (float, optional): Absolute tolerance for the simulation. Defaults to 1e-6.</span>
<span class="sd">    max_steps (int, optional): Maximum number of steps for the simulation. Defaults to 2048.</span>
<span class="sd">    batch_size (int, optional): Batch size for the simulation. Defaults to 1000.</span>
<span class="sd">    normalize (bool, optional): Whether to normalise the solutions. Defaults to True.</span>
<span class="sd">    discretize (bool, optional): Whether to discretize the solutions. Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">    None</span>

<span class="sd">    Note:</span>
<span class="sd">    The results of the simulation are saved in the replicate folders in the specified directory. If the simulation is time series, the results are saved as &#39;timeseries_solutions.parquet&#39; and if the simulation is steady state, the results are saved as &#39;steadystate_solutions.parquet&#39;.</span>

<span class="sd">    Normalisation and discretisation of the solutions are optional. But to discretise the solutions, the normalisation is required.</span>

<span class="sd">    If the discretize flag is set to True, the solutions are discretized and the state counts are saved as &#39;state_counts.csv&#39;, this is only applicable for steady state simulations. If the discretize flag is set to False, the solutions are normalised but not discretized.</span>

<span class="sd">    Example:</span>
<span class="sd">    Run the simulation for the specified topo file</span>

<span class="sd">    &#39;&#39;&#39;python</span>
<span class="sd">    &gt;&gt;&gt; run_all_replicates(topo_file, save_dir, t0, tmax, dt0, tsteps, rel_tol, abs_tol, max_steps, batch_size)</span>
<span class="sd">    &#39;&#39;&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Cheking if discretize is True and normalise is False, if so turn normalise to True</span>
    <span class="k">if</span> <span class="n">discretize</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">normalize</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># Get the name of the topo file</span>
    <span class="n">topo_name</span> <span class="o">=</span> <span class="n">topo_file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Get the list of replicate folders</span>
    <span class="n">replicate_folders</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">folder</span>
            <span class="k">for</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">/*/&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
        <span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># Loop through the replicate folders and run the simulation for each replicate</span>
    <span class="k">for</span> <span class="n">replicate_dir</span> <span class="ow">in</span> <span class="n">replicate_folders</span><span class="p">:</span>
        <span class="c1"># Getting the base name of the replicate directory</span>
        <span class="n">replicate_base</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">replicate_dir</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">))</span>
        <span class="c1"># Load the initial conditions and parameters dataframes</span>
        <span class="n">init_cond_path</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">replicate_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_init_conds_</span><span class="si">{</span><span class="n">replicate_base</span><span class="si">}</span><span class="s2">.parquet&quot;</span>
        <span class="p">)</span>
        <span class="n">params_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">replicate_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_params_</span><span class="si">{</span><span class="n">replicate_base</span><span class="si">}</span><span class="s2">.parquet&quot;</span>
        <span class="c1"># Read the initial conditions and parameters dataframes</span>
        <span class="n">init_conds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">init_cond_path</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">params_path</span><span class="p">)</span>
        <span class="c1"># Starting the timer</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Run the simulation for the specified topo file and given initial conditions and parameters</span>
        <span class="n">sol_df</span> <span class="o">=</span> <span class="n">topo_simulate</span><span class="p">(</span>
            <span class="n">topo_file</span><span class="o">=</span><span class="n">topo_file</span><span class="p">,</span>
            <span class="n">replicate_dir</span><span class="o">=</span><span class="n">replicate_dir</span><span class="p">,</span>
            <span class="n">initial_conditions</span><span class="o">=</span><span class="n">init_conds</span><span class="p">,</span>
            <span class="n">parameters</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">t0</span><span class="o">=</span><span class="n">t0</span><span class="p">,</span>
            <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span>
            <span class="n">dt0</span><span class="o">=</span><span class="n">dt0</span><span class="p">,</span>
            <span class="n">tsteps</span><span class="o">=</span><span class="n">tsteps</span><span class="p">,</span>
            <span class="n">rel_tol</span><span class="o">=</span><span class="n">rel_tol</span><span class="p">,</span>
            <span class="n">abs_tol</span><span class="o">=</span><span class="n">abs_tol</span><span class="p">,</span>
            <span class="n">max_steps</span><span class="o">=</span><span class="n">max_steps</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Ending the timer</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Time taken for replicate </span><span class="si">{</span><span class="n">replicate_base</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">discretize</span><span class="p">:</span>
            <span class="c1"># G/k normalise the solution dataframe</span>
            <span class="n">sol_df</span><span class="p">,</span> <span class="n">state_counts</span> <span class="o">=</span> <span class="n">gk_normalise_solutions</span><span class="p">(</span>
                <span class="n">sol_df</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">sol_df</span> <span class="o">=</span> <span class="n">gk_normalise_solutions</span><span class="p">(</span><span class="n">sol_df</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">discretize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Check if the time seires is given or not to name the solution file</span>
        <span class="k">if</span> <span class="n">tsteps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Save the solution dataframe</span>
            <span class="n">sol_df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">replicate_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_steadystate_solutions_</span><span class="si">{</span><span class="n">replicate_base</span><span class="si">}</span><span class="s2">.parquet&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">discretize</span><span class="p">:</span>
                <span class="n">state_counts</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">replicate_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_steadystate_state_counts_</span><span class="si">{</span><span class="n">replicate_base</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Read the solution dataframe</span>
            <span class="n">sol_df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">replicate_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">topo_name</span><span class="si">}</span><span class="s2">_timeseries_solutions_</span><span class="si">{</span><span class="n">replicate_base</span><span class="si">}</span><span class="s2">.parquet&quot;</span>
            <span class="p">)</span>
        <span class="c1"># # break  ##################################</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><hr />












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2024 CSB Lab, BE Dept, IISc
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.sections", "toc.integrate", "header.autohide"], "search": "../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>